"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports._extractEntryTo = _extractEntryTo;
exports.assertValidZip = assertValidZip;
exports.default = void 0;
exports.extractAllTo = extractAllTo;
exports.readEntries = readEntries;
exports.toArchive = toArchive;
exports.toInMemoryZip = toInMemoryZip;

require("source-map-support/register");

var _lodash = _interopRequireDefault(require("lodash"));

var _bluebird = _interopRequireDefault(require("bluebird"));

var _yauzl = _interopRequireDefault(require("yauzl"));

var _archiver = _interopRequireDefault(require("archiver"));

var _fs = require("fs");

var _path = _interopRequireDefault(require("path"));

var _stream = _interopRequireDefault(require("stream"));

var _fs2 = _interopRequireDefault(require("./fs"));

var _system = require("./system");

var _base64Stream = require("base64-stream");

var _util = require("./util");

var _timing = _interopRequireDefault(require("./timing"));

var _logger = _interopRequireDefault(require("./logger"));

var _getStream = _interopRequireDefault(require("get-stream"));

var _teen_process = require("teen_process");

const openZip = _bluebird.default.promisify(_yauzl.default.open);

const pipeline = _bluebird.default.promisify(_stream.default.pipeline);

const ZIP_MAGIC = 'PK';
const IFMT = 61440;
const IFDIR = 16384;
const IFLNK = 40960;

class ZipExtractor {
  constructor(sourcePath, opts = {}) {
    this.zipPath = sourcePath;
    this.opts = opts;
    this.canceled = false;
  }

  extractFileName(entry) {
    return _lodash.default.isBuffer(entry.fileName) ? entry.fileName.toString(this.opts.fileNamesEncoding) : entry.fileName;
  }

  async extract() {
    const {
      dir,
      fileNamesEncoding
    } = this.opts;
    this.zipfile = await openZip(this.zipPath, {
      lazyEntries: true,
      decodeStrings: !fileNamesEncoding
    });
    this.canceled = false;
    return new _bluebird.default((resolve, reject) => {
      this.zipfile.on('error', err => {
        this.canceled = true;
        reject(err);
      });
      this.zipfile.readEntry();
      this.zipfile.on('close', () => {
        if (!this.canceled) {
          resolve();
        }
      });
      this.zipfile.on('entry', async entry => {
        if (this.canceled) {
          return;
        }

        const fileName = this.extractFileName(entry);

        if (fileName.startsWith('__MACOSX/')) {
          this.zipfile.readEntry();
          return;
        }

        const destDir = _path.default.dirname(_path.default.join(dir, fileName));

        try {
          await _fs2.default.mkdir(destDir, {
            recursive: true
          });
          const canonicalDestDir = await _fs2.default.realpath(destDir);

          const relativeDestDir = _path.default.relative(dir, canonicalDestDir);

          if (relativeDestDir.split(_path.default.sep).includes('..')) {
            new Error(`Out of bound path "${canonicalDestDir}" found while processing file ${fileName}`);
          }

          await this.extractEntry(entry);
          this.zipfile.readEntry();
        } catch (err) {
          this.canceled = true;
          this.zipfile.close();
          reject(err);
        }
      });
    });
  }

  async extractEntry(entry) {
    if (this.canceled) {
      return;
    }

    const {
      dir
    } = this.opts;
    const fileName = this.extractFileName(entry);

    const dest = _path.default.join(dir, fileName);

    const mode = entry.externalFileAttributes >> 16 & 0xFFFF;
    const isSymlink = (mode & IFMT) === IFLNK;
    const isDir = (mode & IFMT) === IFDIR || fileName.endsWith('/') || entry.versionMadeBy >> 8 === 0 && entry.externalFileAttributes === 16;
    const procMode = this.getExtractedMode(mode, isDir) & 0o777;
    const destDir = isDir ? dest : _path.default.dirname(dest);
    const mkdirOptions = {
      recursive: true
    };

    if (isDir) {
      mkdirOptions.mode = procMode;
    }

    await _fs2.default.mkdir(destDir, mkdirOptions);

    if (isDir) {
      return;
    }

    const readStream = await _bluebird.default.promisify(this.zipfile.openReadStream.bind(this.zipfile))(entry);

    if (isSymlink) {
      const link = await (0, _getStream.default)(readStream);
      await _fs2.default.symlink(link, dest);
    } else {
      await pipeline(readStream, _fs2.default.createWriteStream(dest, {
        mode: procMode
      }));
    }
  }

  getExtractedMode(entryMode, isDir) {
    const {
      defaultDirMode,
      defaultFileMode
    } = this.opts;
    let mode = entryMode;

    if (mode === 0) {
      if (isDir) {
        if (defaultDirMode) {
          mode = parseInt(defaultDirMode, 10);
        }

        if (!mode) {
          mode = 0o755;
        }
      } else {
        if (defaultFileMode) {
          mode = parseInt(defaultFileMode, 10);
        }

        if (!mode) {
          mode = 0o644;
        }
      }
    }

    return mode;
  }

}

async function extractAllTo(zipFilePath, destDir, opts = {}) {
  if (!_path.default.isAbsolute(destDir)) {
    throw new Error(`Target path '${destDir}' is expected to be absolute`);
  }

  await _fs2.default.mkdir(destDir, {
    recursive: true
  });
  const dir = await _fs2.default.realpath(destDir);

  if (opts.useSystemUnzip) {
    try {
      await extractWithSystemUnzip(zipFilePath, dir);
      return;
    } catch (err) {
      _logger.default.warn('unzip failed; falling back to JS: %s', err.stderr || err.message);
    }
  }

  const extractor = new ZipExtractor(zipFilePath, { ...opts,
    dir
  });
  await extractor.extract();
}

async function extractWithSystemUnzip(zipFilePath, destDir) {
  const isWindowsHost = (0, _system.isWindows)();
  let executablePath;

  try {
    executablePath = await getExecutablePath(isWindowsHost ? 'powershell.exe' : 'unzip');
  } catch (e) {
    throw new Error('Could not find system unzip');
  }

  if (isWindowsHost) {
    await (0, _teen_process.exec)(executablePath, ['-command', 'Expand-Archive', '-LiteralPath', zipFilePath, '-DestinationPath', destDir, '-Force']);
  } else {
    await (0, _teen_process.exec)(executablePath, ['-q', '-o', zipFilePath, '-d', destDir]);
  }
}

async function _extractEntryTo(zipFile, entry, destDir) {
  const dstPath = _path.default.resolve(destDir, entry.fileName);

  if (/\/$/.test(entry.fileName)) {
    if (!(await _fs2.default.exists(dstPath))) {
      await _fs2.default.mkdirp(dstPath);
    }

    return;
  } else if (!(await _fs2.default.exists(_path.default.dirname(dstPath)))) {
    await _fs2.default.mkdirp(_path.default.dirname(dstPath));
  }

  const writeStream = (0, _fs.createWriteStream)(dstPath, {
    flags: 'w'
  });
  const writeStreamPromise = new _bluebird.default((resolve, reject) => {
    writeStream.once('finish', resolve);
    writeStream.once('error', reject);
  });
  const zipReadStream = await new _bluebird.default((resolve, reject) => {
    zipFile.openReadStream(entry, (err, readStream) => err ? reject(err) : resolve(readStream));
  });
  const zipReadStreamPromise = new _bluebird.default((resolve, reject) => {
    zipReadStream.once('end', resolve);
    zipReadStream.once('error', reject);
  });
  zipReadStream.pipe(writeStream);
  return await _bluebird.default.all([zipReadStreamPromise, writeStreamPromise]);
}

async function readEntries(zipFilePath, onEntry) {
  const zipfile = await openZip(zipFilePath, {
    lazyEntries: true
  });
  const zipReadStreamPromise = new _bluebird.default((resolve, reject) => {
    zipfile.once('end', resolve);
    zipfile.once('error', reject);
    zipfile.on('entry', async entry => {
      const res = await onEntry({
        entry,
        extractEntryTo: async destDir => await _extractEntryTo(zipfile, entry, destDir)
      });

      if (res === false) {
        return zipfile.emit('end');
      }

      zipfile.readEntry();
    });
  });
  zipfile.readEntry();
  return await zipReadStreamPromise;
}

async function toInMemoryZip(srcPath, opts = {}) {
  if (!(await _fs2.default.exists(srcPath))) {
    throw new Error(`No such file or folder: ${srcPath}`);
  }

  const {
    isMetered = true,
    encodeToBase64 = false,
    maxSize = 1 * _util.GiB,
    level = 9
  } = opts;
  const resultBuffers = [];
  let resultBuffersSize = 0;
  const resultWriteStream = new _stream.default.Writable({
    write: (buffer, encoding, next) => {
      resultBuffers.push(buffer);
      resultBuffersSize += buffer.length;

      if (maxSize > 0 && resultBuffersSize > maxSize) {
        resultWriteStream.emit('error', new Error(`The size of the resulting ` + `archive must not be greater than ${(0, _util.toReadableSizeString)(maxSize)}`));
      }

      next();
    }
  });
  const archive = (0, _archiver.default)('zip', {
    zlib: {
      level
    }
  });
  let srcSize = null;
  const base64EncoderStream = encodeToBase64 ? new _base64Stream.Base64Encode() : null;
  const resultWriteStreamPromise = new _bluebird.default((resolve, reject) => {
    resultWriteStream.once('error', e => {
      if (base64EncoderStream) {
        archive.unpipe(base64EncoderStream);
        base64EncoderStream.unpipe(resultWriteStream);
      } else {
        archive.unpipe(resultWriteStream);
      }

      archive.abort();
      archive.destroy();
      reject(e);
    });
    resultWriteStream.once('finish', () => {
      srcSize = archive.pointer();
      resolve();
    });
  });
  const archiveStreamPromise = new _bluebird.default((resolve, reject) => {
    archive.once('finish', resolve);
    archive.once('error', e => reject(new Error(`Failed to archive '${srcPath}': ${e.message}`)));
  });
  const timer = isMetered ? new _timing.default().start() : null;

  if ((await _fs2.default.stat(srcPath)).isDirectory()) {
    archive.directory(srcPath, false);
  } else {
    archive.file(srcPath, {
      name: _path.default.basename(srcPath)
    });
  }

  if (base64EncoderStream) {
    archive.pipe(base64EncoderStream);
    base64EncoderStream.pipe(resultWriteStream);
  } else {
    archive.pipe(resultWriteStream);
  }

  archive.finalize();
  await _bluebird.default.all([archiveStreamPromise, resultWriteStreamPromise]);

  if (timer) {
    _logger.default.debug(`Zipped ${encodeToBase64 ? 'and base64-encoded ' : ''}` + `'${_path.default.basename(srcPath)}' ` + (srcSize ? `(${(0, _util.toReadableSizeString)(srcSize)}) ` : '') + `in ${timer.getDuration().asSeconds.toFixed(3)}s ` + `(compression level: ${level})`);
  }

  return Buffer.concat(resultBuffers);
}

async function assertValidZip(filePath) {
  if (!(await _fs2.default.exists(filePath))) {
    throw new Error(`The file at '${filePath}' does not exist`);
  }

  const {
    size
  } = await _fs2.default.stat(filePath);

  if (size < 4) {
    throw new Error(`The file at '${filePath}' is too small to be a ZIP archive`);
  }

  const fd = await _fs2.default.open(filePath, 'r');

  try {
    const buffer = Buffer.alloc(ZIP_MAGIC.length);
    await _fs2.default.read(fd, buffer, 0, ZIP_MAGIC.length, 0);
    const signature = buffer.toString('ascii');

    if (signature !== ZIP_MAGIC) {
      throw new Error(`The file signature '${signature}' of '${filePath}' ` + `is not equal to the expected ZIP archive signature '${ZIP_MAGIC}'`);
    }

    return true;
  } finally {
    await _fs2.default.close(fd);
  }
}

async function toArchive(dstPath, src = {}, opts = {}) {
  const {
    level = 9
  } = opts;
  const {
    pattern = '**/*',
    cwd = _path.default.dirname(dstPath),
    ignore = []
  } = src;
  const archive = (0, _archiver.default)('zip', {
    zlib: {
      level
    }
  });

  const stream = _fs2.default.createWriteStream(dstPath);

  return await new _bluebird.default((resolve, reject) => {
    archive.glob(pattern, {
      cwd,
      ignore
    }).on('error', reject).pipe(stream);
    stream.on('error', e => {
      archive.unpipe(stream);
      archive.abort();
      archive.destroy();
      reject(e);
    }).on('finish', resolve);
    archive.finalize();
  });
}

const getExecutablePath = _lodash.default.memoize(async function getExecutablePath(binaryName) {
  const fullPath = await _fs2.default.which(binaryName);

  _logger.default.debug(`Found '%s' at '%s'`, binaryName, fullPath);

  return fullPath;
});

var _default = {
  extractAllTo,
  readEntries,
  toInMemoryZip,
  assertValidZip,
  toArchive
};
exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL2xpYi96aXAuanMiXSwibmFtZXMiOlsib3BlblppcCIsIkIiLCJwcm9taXNpZnkiLCJ5YXV6bCIsIm9wZW4iLCJwaXBlbGluZSIsInN0cmVhbSIsIlpJUF9NQUdJQyIsIklGTVQiLCJJRkRJUiIsIklGTE5LIiwiWmlwRXh0cmFjdG9yIiwiY29uc3RydWN0b3IiLCJzb3VyY2VQYXRoIiwib3B0cyIsInppcFBhdGgiLCJjYW5jZWxlZCIsImV4dHJhY3RGaWxlTmFtZSIsImVudHJ5IiwiXyIsImlzQnVmZmVyIiwiZmlsZU5hbWUiLCJ0b1N0cmluZyIsImZpbGVOYW1lc0VuY29kaW5nIiwiZXh0cmFjdCIsImRpciIsInppcGZpbGUiLCJsYXp5RW50cmllcyIsImRlY29kZVN0cmluZ3MiLCJyZXNvbHZlIiwicmVqZWN0Iiwib24iLCJlcnIiLCJyZWFkRW50cnkiLCJzdGFydHNXaXRoIiwiZGVzdERpciIsInBhdGgiLCJkaXJuYW1lIiwiam9pbiIsImZzIiwibWtkaXIiLCJyZWN1cnNpdmUiLCJjYW5vbmljYWxEZXN0RGlyIiwicmVhbHBhdGgiLCJyZWxhdGl2ZURlc3REaXIiLCJyZWxhdGl2ZSIsInNwbGl0Iiwic2VwIiwiaW5jbHVkZXMiLCJFcnJvciIsImV4dHJhY3RFbnRyeSIsImNsb3NlIiwiZGVzdCIsIm1vZGUiLCJleHRlcm5hbEZpbGVBdHRyaWJ1dGVzIiwiaXNTeW1saW5rIiwiaXNEaXIiLCJlbmRzV2l0aCIsInZlcnNpb25NYWRlQnkiLCJwcm9jTW9kZSIsImdldEV4dHJhY3RlZE1vZGUiLCJta2Rpck9wdGlvbnMiLCJyZWFkU3RyZWFtIiwib3BlblJlYWRTdHJlYW0iLCJiaW5kIiwibGluayIsInN5bWxpbmsiLCJjcmVhdGVXcml0ZVN0cmVhbSIsImVudHJ5TW9kZSIsImRlZmF1bHREaXJNb2RlIiwiZGVmYXVsdEZpbGVNb2RlIiwicGFyc2VJbnQiLCJleHRyYWN0QWxsVG8iLCJ6aXBGaWxlUGF0aCIsImlzQWJzb2x1dGUiLCJ1c2VTeXN0ZW1VbnppcCIsImV4dHJhY3RXaXRoU3lzdGVtVW56aXAiLCJsb2ciLCJ3YXJuIiwic3RkZXJyIiwibWVzc2FnZSIsImV4dHJhY3RvciIsImlzV2luZG93c0hvc3QiLCJleGVjdXRhYmxlUGF0aCIsImdldEV4ZWN1dGFibGVQYXRoIiwiZSIsIl9leHRyYWN0RW50cnlUbyIsInppcEZpbGUiLCJkc3RQYXRoIiwidGVzdCIsImV4aXN0cyIsIm1rZGlycCIsIndyaXRlU3RyZWFtIiwiZmxhZ3MiLCJ3cml0ZVN0cmVhbVByb21pc2UiLCJvbmNlIiwiemlwUmVhZFN0cmVhbSIsInppcFJlYWRTdHJlYW1Qcm9taXNlIiwicGlwZSIsImFsbCIsInJlYWRFbnRyaWVzIiwib25FbnRyeSIsInJlcyIsImV4dHJhY3RFbnRyeVRvIiwiZW1pdCIsInRvSW5NZW1vcnlaaXAiLCJzcmNQYXRoIiwiaXNNZXRlcmVkIiwiZW5jb2RlVG9CYXNlNjQiLCJtYXhTaXplIiwiR2lCIiwibGV2ZWwiLCJyZXN1bHRCdWZmZXJzIiwicmVzdWx0QnVmZmVyc1NpemUiLCJyZXN1bHRXcml0ZVN0cmVhbSIsIldyaXRhYmxlIiwid3JpdGUiLCJidWZmZXIiLCJlbmNvZGluZyIsIm5leHQiLCJwdXNoIiwibGVuZ3RoIiwiYXJjaGl2ZSIsInpsaWIiLCJzcmNTaXplIiwiYmFzZTY0RW5jb2RlclN0cmVhbSIsIkJhc2U2NEVuY29kZSIsInJlc3VsdFdyaXRlU3RyZWFtUHJvbWlzZSIsInVucGlwZSIsImFib3J0IiwiZGVzdHJveSIsInBvaW50ZXIiLCJhcmNoaXZlU3RyZWFtUHJvbWlzZSIsInRpbWVyIiwiVGltZXIiLCJzdGFydCIsInN0YXQiLCJpc0RpcmVjdG9yeSIsImRpcmVjdG9yeSIsImZpbGUiLCJuYW1lIiwiYmFzZW5hbWUiLCJmaW5hbGl6ZSIsImRlYnVnIiwiZ2V0RHVyYXRpb24iLCJhc1NlY29uZHMiLCJ0b0ZpeGVkIiwiQnVmZmVyIiwiY29uY2F0IiwiYXNzZXJ0VmFsaWRaaXAiLCJmaWxlUGF0aCIsInNpemUiLCJmZCIsImFsbG9jIiwicmVhZCIsInNpZ25hdHVyZSIsInRvQXJjaGl2ZSIsInNyYyIsInBhdHRlcm4iLCJjd2QiLCJpZ25vcmUiLCJnbG9iIiwibWVtb2l6ZSIsImJpbmFyeU5hbWUiLCJmdWxsUGF0aCIsIndoaWNoIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUVBLE1BQU1BLE9BQU8sR0FBR0Msa0JBQUVDLFNBQUYsQ0FBWUMsZUFBTUMsSUFBbEIsQ0FBaEI7O0FBQ0EsTUFBTUMsUUFBUSxHQUFHSixrQkFBRUMsU0FBRixDQUFZSSxnQkFBT0QsUUFBbkIsQ0FBakI7O0FBQ0EsTUFBTUUsU0FBUyxHQUFHLElBQWxCO0FBQ0EsTUFBTUMsSUFBSSxHQUFHLEtBQWI7QUFDQSxNQUFNQyxLQUFLLEdBQUcsS0FBZDtBQUNBLE1BQU1DLEtBQUssR0FBRyxLQUFkOztBQUdBLE1BQU1DLFlBQU4sQ0FBbUI7QUFDakJDLEVBQUFBLFdBQVcsQ0FBRUMsVUFBRixFQUFjQyxJQUFJLEdBQUcsRUFBckIsRUFBeUI7QUFDbEMsU0FBS0MsT0FBTCxHQUFlRixVQUFmO0FBQ0EsU0FBS0MsSUFBTCxHQUFZQSxJQUFaO0FBQ0EsU0FBS0UsUUFBTCxHQUFnQixLQUFoQjtBQUNEOztBQUVEQyxFQUFBQSxlQUFlLENBQUVDLEtBQUYsRUFBUztBQUN0QixXQUFPQyxnQkFBRUMsUUFBRixDQUFXRixLQUFLLENBQUNHLFFBQWpCLElBQTZCSCxLQUFLLENBQUNHLFFBQU4sQ0FBZUMsUUFBZixDQUF3QixLQUFLUixJQUFMLENBQVVTLGlCQUFsQyxDQUE3QixHQUFvRkwsS0FBSyxDQUFDRyxRQUFqRztBQUNEOztBQUVZLFFBQVBHLE9BQU8sR0FBSTtBQUNmLFVBQU07QUFDSkMsTUFBQUEsR0FESTtBQUVKRixNQUFBQTtBQUZJLFFBR0YsS0FBS1QsSUFIVDtBQUlBLFNBQUtZ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QU87QUFDbEJxQyxNQUFBQSxPQUFPLENBQUNNLE1BQVIsQ0FBZTFILE1BQWY7QUFDQW9ILE1BQUFBLE9BQU8sQ0FBQ08sS0FBUjtBQUNBUCxNQUFBQSxPQUFPLENBQUNRLE9BQVI7QUFDQXBHLE1BQUFBLE1BQU0sQ0FBQ3VELENBQUQsQ0FBTjtBQUNELEtBTkgsRUFPR3RELEVBUEgsQ0FPTSxRQVBOLEVBT2dCRixPQVBoQjtBQVFBNkYsSUFBQUEsT0FBTyxDQUFDb0IsUUFBUjtBQUNELEdBakJZLENBQWI7QUFrQkQ7O0FBTUQsTUFBTTFELGlCQUFpQixHQUFHakUsZ0JBQUUrSSxPQUFGLENBSXhCLGVBQWU5RSxpQkFBZixDQUFrQytFLFVBQWxDLEVBQThDO0FBQzVDLFFBQU1DLFFBQVEsR0FBRyxNQUFNN0gsYUFBRzhILEtBQUgsQ0FBU0YsVUFBVCxDQUF2Qjs7QUFDQXRGLGtCQUFJa0UsS0FBSixDQUFXLG9CQUFYLEVBQWdDb0IsVUFBaEMsRUFBNENDLFFBQTVDOztBQUNBLFNBQU9BLFFBQVA7QUFDRCxDQVJ1QixDQUExQjs7ZUFhZTtBQUFFNUYsRUFBQUEsWUFBRjtBQUFnQjRCLEVBQUFBLFdBQWhCO0FBQTZCSyxFQUFBQSxhQUE3QjtBQUE0QzRDLEVBQUFBLGNBQTVDO0FBQTRETyxFQUFBQTtBQUE1RCxDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IF8gZnJvbSAnbG9kYXNoJztcbmltcG9ydCBCIGZyb20gJ2JsdWViaXJkJztcbmltcG9ydCB5YXV6bCBmcm9tICd5YXV6bCc7XG5pbXBvcnQgYXJjaGl2ZXIgZnJvbSAnYXJjaGl2ZXInO1xuaW1wb3J0IHsgY3JlYXRlV3JpdGVTdHJlYW0gfSBmcm9tICdmcyc7XG5pbXBvcnQgcGF0aCBmcm9tICdwYXRoJztcbmltcG9ydCBzdHJlYW0gZnJvbSAnc3RyZWFtJztcbmltcG9ydCBmcyBmcm9tICcuL2ZzJztcbmltcG9ydCB7IGlzV2luZG93cyB9IGZyb20gJy4vc3lzdGVtJztcbmltcG9ydCB7IEJhc2U2NEVuY29kZSB9IGZyb20gJ2Jhc2U2NC1zdHJlYW0nO1xuaW1wb3J0IHsgdG9SZWFkYWJsZVNpemVTdHJpbmcsIEdpQiB9IGZyb20gJy4vdXRpbCc7XG5pbXBvcnQgVGltZXIgZnJvbSAnLi90aW1pbmcnO1xuaW1wb3J0IGxvZyBmcm9tICcuL2xvZ2dlcic7XG5pbXBvcnQgZ2V0U3RyZWFtIGZyb20gJ2dldC1zdHJlYW0nO1xuaW1wb3J0IHsgZXhlYyB9IGZyb20gJ3RlZW5fcHJvY2Vzcyc7XG5cbmNvbnN0IG9wZW5aaXAgPSBCLnByb21pc2lmeSh5YXV6bC5vcGVuKTtcbmNvbnN0IHBpcGVsaW5lID0gQi5wcm9taXNpZnkoc3RyZWFtLnBpcGVsaW5lKTtcbmNvbnN0IFpJUF9NQUdJQyA9ICdQSyc7XG5jb25zdCBJRk1UID0gNjE0NDA7XG5jb25zdCBJRkRJUiA9IDE2Mzg0O1xuY29uc3QgSUZMTksgPSA0MDk2MDtcblxuLy8gVGhpcyBjbGFzcyBpcyBtb3N0bHkgY29waWVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL21heG9nZGVuL2V4dHJhY3QtemlwL2Jsb2IvbWFzdGVyL2luZGV4LmpzXG5jbGFzcyBaaXBFeHRyYWN0b3Ige1xuICBjb25zdHJ1Y3RvciAoc291cmNlUGF0aCwgb3B0cyA9IHt9KSB7XG4gICAgdGhpcy56aXBQYXRoID0gc291cmNlUGF0aDtcbiAgICB0aGlzLm9wdHMgPSBvcHRzO1xuICAgIHRoaXMuY2FuY2VsZWQgPSBmYWxzZTtcbiAgfVxuXG4gIGV4dHJhY3RGaWxlTmFtZSAoZW50cnkpIHtcbiAgICByZXR1cm4gXy5pc0J1ZmZlcihlbnRyeS5maWxlTmFtZSkgPyBlbnRyeS5maWxlTmFtZS50b1N0cmluZyh0aGlzLm9wdHMuZmlsZU5hbWVzRW5jb2RpbmcpIDogZW50cnkuZmlsZU5hbWU7XG4gIH1cblxuICBhc3luYyBleHRyYWN0ICgpIHtcbiAgICBjb25zdCB7XG4gICAgICBkaXIsXG4gICAgICBmaWxlTmFtZXNFbmNvZGluZyxcbiAgICB9ID0gdGhpcy5vcHRzO1xuICAgIHRoaXMuemlwZmlsZSA9IGF3YWl0IG9wZW5aaXAodGhpcy56aXBQYXRoLCB7XG4gICAgICBsYXp5RW50cmllczogdHJ1ZSxcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS90aGVqb3Nod29sZmUveWF1emwvY29tbWl0L2NjNzQ1NWFjNzg5YmE4NDk3MzE4NGU1ZWJkZTA1ODFjZGM0YzNiMzkjZGlmZi0wNGM2ZTkwZmFhYzI2NzVhYTg5ZTIxNzZkMmVlYzdkOFI5NVxuICAgICAgZGVjb2RlU3RyaW5nczogIWZpbGVOYW1lc0VuY29kaW5nLFxuICAgIH0pO1xuICAgIHRoaXMuY2FuY2VsZWQgPSBmYWxzZTtcblxuICAgIHJldHVybiBuZXcgQigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0aGlzLnppcGZpbGUub24oJ2Vycm9yJywgKGVycikgPT4ge1xuICAgICAgICB0aGlzLmNhbmNlbGVkID0gdHJ1ZTtcbiAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuemlwZmlsZS5yZWFkRW50cnkoKTtcblxuICAgICAgdGhpcy56aXBmaWxlLm9uKCdjbG9zZScsICgpID0+IHtcbiAgICAgICAgaWYgKCF0aGlzLmNhbmNlbGVkKSB7XG4gICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgdGhpcy56aXBmaWxlLm9uKCdlbnRyeScsIGFzeW5jIChlbnRyeSkgPT4ge1xuICAgICAgICBpZiAodGhpcy5jYW5jZWxlZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGZpbGVOYW1lID0gdGhpcy5leHRyYWN0RmlsZU5hbWUoZW50cnkpO1xuICAgICAgICBpZiAoZmlsZU5hbWUuc3RhcnRzV2l0aCgnX19NQUNPU1gvJykpIHtcbiAgICAgICAgICB0aGlzLnppcGZpbGUucmVhZEVudHJ5KCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZGVzdERpciA9IHBhdGguZGlybmFtZShwYXRoLmpvaW4oZGlyLCBmaWxlTmFtZSkpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGF3YWl0IGZzLm1rZGlyKGRlc3REaXIsIHtyZWN1cnNpdmU6IHRydWV9KTtcblxuICAgICAgICAgIGNvbnN0IGNhbm9uaWNhbERlc3REaXIgPSBhd2FpdCBmcy5yZWFscGF0aChkZXN0RGlyKTtcbiAgICAgICAgICBjb25zdCByZWxhdGl2ZURlc3REaXIgPSBwYXRoLnJlbGF0aXZlKGRpciwgY2Fub25pY2FsRGVzdERpcik7XG5cbiAgICAgICAgICBpZiAocmVsYXRpdmVEZXN0RGlyLnNwbGl0KHBhdGguc2VwKS5pbmNsdWRlcygnLi4nKSkge1xuICAgICAgICAgICAgbmV3IEVycm9yKGBPdXQgb2YgYm91bmQgcGF0aCBcIiR7Y2Fub25pY2FsRGVzdERpcn1cIiBmb3VuZCB3aGlsZSBwcm9jZXNzaW5nIGZpbGUgJHtmaWxlTmFtZX1gKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBhd2FpdCB0aGlzLmV4dHJhY3RFbnRyeShlbnRyeSk7XG4gICAgICAgICAgdGhpcy56aXBmaWxlLnJlYWRFbnRyeSgpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICB0aGlzLmNhbmNlbGVkID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzLnppcGZpbGUuY2xvc2UoKTtcbiAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBhc3luYyBleHRyYWN0RW50cnkgKGVudHJ5KSB7XG4gICAgaWYgKHRoaXMuY2FuY2VsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCB7XG4gICAgICBkaXIsXG4gICAgfSA9IHRoaXMub3B0cztcblxuICAgIGNvbnN0IGZpbGVOYW1lID0gdGhpcy5leHRyYWN0RmlsZU5hbWUoZW50cnkpO1xuICAgIGNvbnN0IGRlc3QgPSBwYXRoLmpvaW4oZGlyLCBmaWxlTmFtZSk7XG5cbiAgICAvLyBjb252ZXJ0IGV4dGVybmFsIGZpbGUgYXR0ciBpbnQgaW50byBhIGZzIHN0YXQgbW9kZSBpbnRcbiAgICBjb25zdCBtb2RlID0gKGVudHJ5LmV4dGVybmFsRmlsZUF0dHJpYnV0ZXMgPj4gMTYpICYgMHhGRkZGO1xuICAgIC8vIGNoZWNrIGlmIGl0J3MgYSBzeW1saW5rIG9yIGRpciAodXNpbmcgc3RhdCBtb2RlIGNvbnN0YW50cylcbiAgICBjb25zdCBpc1N5bWxpbmsgPSAobW9kZSAmIElGTVQpID09PSBJRkxOSztcbiAgICBjb25zdCBpc0RpciA9IChtb2RlICYgSUZNVCkgPT09IElGRElSXG4gICAgICAvLyBGYWlsc2FmZSwgYm9ycm93ZWQgZnJvbSBqc1ppcFxuICAgICAgfHwgZmlsZU5hbWUuZW5kc1dpdGgoJy8nKVxuICAgICAgLy8gY2hlY2sgZm9yIHdpbmRvd3Mgd2VpcmQgd2F5IG9mIHNwZWNpZnlpbmcgYSBkaXJlY3RvcnlcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXhvZ2Rlbi9leHRyYWN0LXppcC9pc3N1ZXMvMTMjaXNzdWVjb21tZW50LTE1NDQ5NDU2NlxuICAgICAgfHwgKGVudHJ5LnZlcnNpb25NYWRlQnkgPj4gOCA9PT0gMCAmJiBlbnRyeS5leHRlcm5hbEZpbGVBdHRyaWJ1dGVzID09PSAxNik7XG4gICAgY29uc3QgcHJvY01vZGUgPSB0aGlzLmdldEV4dHJhY3RlZE1vZGUobW9kZSwgaXNEaXIpICYgMG83Nzc7XG4gICAgLy8gYWx3YXlzIGVuc3VyZSBmb2xkZXJzIGFyZSBjcmVhdGVkXG4gICAgY29uc3QgZGVzdERpciA9IGlzRGlyID8gZGVzdCA6IHBhdGguZGlybmFtZShkZXN0KTtcbiAgICBjb25zdCBta2Rpck9wdGlvbnMgPSB7IHJlY3Vyc2l2ZTogdHJ1ZSB9O1xuICAgIGlmIChpc0Rpcikge1xuICAgICAgbWtkaXJPcHRpb25zLm1vZGUgPSBwcm9jTW9kZTtcbiAgICB9XG4gICAgYXdhaXQgZnMubWtkaXIoZGVzdERpciwgbWtkaXJPcHRpb25zKTtcbiAgICBpZiAoaXNEaXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCByZWFkU3RyZWFtID0gYXdhaXQgQi5wcm9taXNpZnkodGhpcy56aXBmaWxlLm9wZW5SZWFkU3RyZWFtLmJpbmQodGhpcy56aXBmaWxlKSkoZW50cnkpO1xuICAgIGlmIChpc1N5bWxpbmspIHtcbiAgICAgIGNvbnN0IGxpbmsgPSBhd2FpdCBnZXRTdHJlYW0ocmVhZFN0cmVhbSk7XG4gICAgICBhd2FpdCBmcy5zeW1saW5rKGxpbmssIGRlc3QpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhd2FpdCBwaXBlbGluZShyZWFkU3RyZWFtLCBmcy5jcmVhdGVXcml0ZVN0cmVhbShkZXN0LCB7IG1vZGU6IHByb2NNb2RlIH0pKTtcbiAgICB9XG4gIH1cblxuICBnZXRFeHRyYWN0ZWRNb2RlIChlbnRyeU1vZGUsIGlzRGlyKSB7XG4gICAgY29uc3Qge1xuICAgICAgZGVmYXVsdERpck1vZGUsXG4gICAgICBkZWZhdWx0RmlsZU1vZGUsXG4gICAgfSA9IHRoaXMub3B0cztcblxuICAgIGxldCBtb2RlID0gZW50cnlNb2RlO1xuICAgIC8vIFNldCBkZWZhdWx0cywgaWYgbmVjZXNzYXJ5XG4gICAgaWYgKG1vZGUgPT09IDApIHtcbiAgICAgIGlmIChpc0Rpcikge1xuICAgICAgICBpZiAoZGVmYXVsdERpck1vZGUpIHtcbiAgICAgICAgICBtb2RlID0gcGFyc2VJbnQoZGVmYXVsdERpck1vZGUsIDEwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghbW9kZSkge1xuICAgICAgICAgIG1vZGUgPSAwbzc1NTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGRlZmF1bHRGaWxlTW9kZSkge1xuICAgICAgICAgIG1vZGUgPSBwYXJzZUludChkZWZhdWx0RmlsZU1vZGUsIDEwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghbW9kZSkge1xuICAgICAgICAgIG1vZGUgPSAwbzY0NDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBtb2RlO1xuICB9XG59XG5cblxuLyoqXG4gKiBAdHlwZWRlZiBFeHRyYWN0QWxsT3B0aW9uc1xuICogQHByb3BlcnR5IHs/c3RyaW5nfSBmaWxlTmFtZXNFbmNvZGluZyBUaGUgZW5jb2RpbmcgdG8gdXNlIGZvciBleHRyYWN0ZWQgZmlsZSBuYW1lcy5cbiAqIEZvciBaSVAgYXJjaGl2ZXMgY3JlYXRlZCBvbiBNYWNPUyBpdCBpcyB1c3VhbGx5IGV4cGVjdGVkIHRvIGJlIGB1dGY4YC5cbiAqIEJ5IGRlZmF1bHQgaXQgaXMgYXV0b2RldGVjdGVkIGJhc2VkIG9uIHRoZSBlbnRyeSBtZXRhZGF0YSBhbmQgaXMgb25seSBuZWVkZWQgdG8gYmUgc2V0IGV4cGxpY2l0bHlcbiAqIGlmIHRoZSBwYXJ0aWN1bGFyIGFyY2hpdmUgZG9lcyBub3QgY29tcGx5IHRvIHRoZSBzdGFuZGFyZHMsIHdoaWNoIGxlYWRzIHRvIGNvcnJ1cHRlZCBmaWxlIG5hbWVzXG4gKiBhZnRlciBleHRyYWN0aW9uLiBPbmx5IGFwcGxpY2FibGUgaWYgc3lzdGVtIHVuemlwIGJpbmFyeSBpcyBOT1QgYmVpbmcgdXNlZC5cbiAqIEBwcm9wZXJ0eSB7P2Jvb2xlYW59IHVzZVN5c3RlbVVuemlwIFtmYWxzZV0gSWYgdHJ1ZSwgYXR0ZW1wdCB0byB1c2Ugc3lzdGVtIHVuemlwOyBpZiB0aGlzIGZhaWxzLFxuICogZmFsbGJhY2sgdG8gdGhlIEpTIHVuemlwIGltcGxlbWVudGF0aW9uLlxuICovXG5cbi8qKlxuICogRXh0cmFjdCB6aXBmaWxlIHRvIGEgZGlyZWN0b3J5XG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHppcEZpbGVQYXRoIFRoZSBmdWxsIHBhdGggdG8gdGhlIHNvdXJjZSBaSVAgZmlsZVxuICogQHBhcmFtIHtzdHJpbmd9IGRlc3REaXIgVGhlIGZ1bGwgcGF0aCB0byB0aGUgZGVzdGluYXRpb24gZm9sZGVyXG4gKiBAcGFyYW0gez9FeHRyYWN0QWxsT3B0aW9uc30gb3B0c1xuICovXG5hc3luYyBmdW5jdGlvbiBleHRyYWN0QWxsVG8gKHppcEZpbGVQYXRoLCBkZXN0RGlyLCBvcHRzID0ge30pIHtcbiAgaWYgKCFwYXRoLmlzQWJzb2x1dGUoZGVzdERpcikpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFRhcmdldCBwYXRoICcke2Rlc3REaXJ9JyBpcyBleHBlY3RlZCB0byBiZSBhYnNvbHV0ZWApO1xuICB9XG5cbiAgYXdhaXQgZnMubWtkaXIoZGVzdERpciwge3JlY3Vyc2l2ZTogdHJ1ZX0pO1xuICBjb25zdCBkaXIgPSBhd2FpdCBmcy5yZWFscGF0aChkZXN0RGlyKTtcbiAgaWYgKG9wdHMudXNlU3lzdGVtVW56aXApIHtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgZXh0cmFjdFdpdGhTeXN0ZW1VbnppcCh6aXBGaWxlUGF0aCwgZGlyKTtcbiAgICAgIHJldHVybjtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGxvZy53YXJuKCd1bnppcCBmYWlsZWQ7IGZhbGxpbmcgYmFjayB0byBKUzogJXMnLCBlcnIuc3RkZXJyIHx8IGVyci5tZXNzYWdlKTtcbiAgICB9XG4gIH1cbiAgY29uc3QgZXh0cmFjdG9yID0gbmV3IFppcEV4dHJhY3Rvcih6aXBGaWxlUGF0aCwge1xuICAgIC4uLm9wdHMsXG4gICAgZGlyLFxuICB9KTtcbiAgYXdhaXQgZXh0cmFjdG9yLmV4dHJhY3QoKTtcbn1cblxuLyoqXG4gKiBFeGVjdXRlcyBzeXN0ZW0gdW56aXAgKGUuZy4sIGAvdXNyL2Jpbi91bnppcGApLiBJZiBhdmFpbGFibGUsIGl0IGlzXG4gKiBzaWduaWZpY2FudGx5IGZhc3RlciB0aGFuIHRoZSBKUyBpbXBsZW1lbnRhdGlvbi5cbiAqIEJ5IGRlZmF1bHQgYWxsIGZpbGVzIGluIHRoZSBkZXN0RGlyIGdldCBvdmVycmlkZGVuIGlmIGFscmVhZHkgZXhpc3QuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHppcEZpbGVQYXRoIFRoZSBmdWxsIHBhdGggdG8gdGhlIHNvdXJjZSBaSVAgZmlsZVxuICogQHBhcmFtIHtzdHJpbmd9IGRlc3REaXIgVGhlIGZ1bGwgcGF0aCB0byB0aGUgZGVzdGluYXRpb24gZm9sZGVyLlxuICogVGhpcyBmb2xkZXIgaXMgZXhwZWN0ZWQgdG8gYWxyZWFkeSBleGlzdCBiZWZvcmUgZXh0cmFjdGluZyB0aGUgYXJjaGl2ZS5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gZXh0cmFjdFdpdGhTeXN0ZW1VbnppcCAoemlwRmlsZVBhdGgsIGRlc3REaXIpIHtcbiAgY29uc3QgaXNXaW5kb3dzSG9zdCA9IGlzV2luZG93cygpO1xuICBsZXQgZXhlY3V0YWJsZVBhdGg7XG4gIHRyeSB7XG4gICAgZXhlY3V0YWJsZVBhdGggPSBhd2FpdCBnZXRFeGVjdXRhYmxlUGF0aChcbiAgICAgIGlzV2luZG93c0hvc3QgPyAncG93ZXJzaGVsbC5leGUnIDogJ3VuemlwJ1xuICAgICk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBmaW5kIHN5c3RlbSB1bnppcCcpO1xuICB9XG5cbiAgaWYgKGlzV2luZG93c0hvc3QpIHtcbiAgICAvLyBvbiBXaW5kb3dzIHdlIHVzZSBQb3dlclNoZWxsIHRvIHVuemlwIGZpbGVzXG4gICAgYXdhaXQgZXhlYyhleGVjdXRhYmxlUGF0aCwgW1xuICAgICAgJy1jb21tYW5kJywgJ0V4cGFuZC1BcmNoaXZlJyxcbiAgICAgICctTGl0ZXJhbFBhdGgnLCB6aXBGaWxlUGF0aCxcbiAgICAgICctRGVzdGluYXRpb25QYXRoJywgZGVzdERpcixcbiAgICAgICctRm9yY2UnXG4gICAgXSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gLXEgbWVhbnMgcXVpZXQgKG5vIHN0ZG91dClcbiAgICAvLyAtbyBtZWFucyBvdmVyd3JpdGVcbiAgICAvLyAtZCBpcyB0aGUgZGVzdCBkaXJcbiAgICBhd2FpdCBleGVjKGV4ZWN1dGFibGVQYXRoLCBbXG4gICAgICAnLXEnLFxuICAgICAgJy1vJywgemlwRmlsZVBhdGgsXG4gICAgICAnLWQnLCBkZXN0RGlyXG4gICAgXSk7XG4gIH1cbn1cblxuLyoqXG4gKiBFeHRyYWN0IGEgc2luZ2xlIHppcCBlbnRyeSB0byBhIGRpcmVjdG9yeVxuICpcbiAqIEBwYXJhbSB7U3RyZWFtYWJsZX0gemlwRmlsZSBUaGUgc291cmNlIFpJUCBzdHJlYW1cbiAqIEBwYXJhbSB7eWF1emwuWmlwRW50cnl9IGVudHJ5IFRoZSBlbnRyeSBpbnN0YW5jZVxuICogQHBhcmFtIHtzdHJpbmd9IGRlc3REaXIgVGhlIGZ1bGwgcGF0aCB0byB0aGUgZGVzdGluYXRpb24gZm9sZGVyXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIF9leHRyYWN0RW50cnlUbyAoemlwRmlsZSwgZW50cnksIGRlc3REaXIpIHtcbiAgY29uc3QgZHN0UGF0aCA9IHBhdGgucmVzb2x2ZShkZXN0RGlyLCBlbnRyeS5maWxlTmFtZSk7XG5cbiAgLy8gQ3JlYXRlIGRlc3QgZGlyZWN0b3J5IGlmIGRvZXNuJ3QgZXhpc3QgYWxyZWFkeVxuICBpZiAoL1xcLyQvLnRlc3QoZW50cnkuZmlsZU5hbWUpKSB7XG4gICAgaWYgKCFhd2FpdCBmcy5leGlzdHMoZHN0UGF0aCkpIHtcbiAgICAgIGF3YWl0IGZzLm1rZGlycChkc3RQYXRoKTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9IGVsc2UgaWYgKCFhd2FpdCBmcy5leGlzdHMocGF0aC5kaXJuYW1lKGRzdFBhdGgpKSkge1xuICAgIGF3YWl0IGZzLm1rZGlycChwYXRoLmRpcm5hbWUoZHN0UGF0aCkpO1xuICB9XG5cbiAgLy8gQ3JlYXRlIGEgd3JpdGUgc3RyZWFtXG4gIGNvbnN0IHdyaXRlU3RyZWFtID0gY3JlYXRlV3JpdGVTdHJlYW0oZHN0UGF0aCwge2ZsYWdzOiAndyd9KTtcbiAgY29uc3Qgd3JpdGVTdHJlYW1Qcm9taXNlID0gbmV3IEIoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIHdyaXRlU3RyZWFtLm9uY2UoJ2ZpbmlzaCcsIHJlc29sdmUpO1xuICAgIHdyaXRlU3RyZWFtLm9uY2UoJ2Vycm9yJywgcmVqZWN0KTtcbiAgfSk7XG5cbiAgLy8gQ3JlYXRlIHppcFJlYWRTdHJlYW0gYW5kIHBpcGUgZGF0YSB0byB0aGUgd3JpdGUgc3RyZWFtXG4gIC8vIChmb3Igc29tZSBvZGQgcmVhc29uIEIucHJvbWlzaWZ5IGRvZXNuJ3Qgd29yayBvbiB6aXBmaWxlLm9wZW5SZWFkU3RyZWFtLCBpdCBjYXVzZXMgYW4gZXJyb3IgJ2Nsb3NlZCcpXG4gIGNvbnN0IHppcFJlYWRTdHJlYW0gPSBhd2FpdCBuZXcgQigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgemlwRmlsZS5vcGVuUmVhZFN0cmVhbShlbnRyeSwgKGVyciwgcmVhZFN0cmVhbSkgPT4gZXJyID8gcmVqZWN0KGVycikgOiByZXNvbHZlKHJlYWRTdHJlYW0pKTtcbiAgfSk7XG4gIGNvbnN0IHppcFJlYWRTdHJlYW1Qcm9taXNlID0gbmV3IEIoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIHppcFJlYWRTdHJlYW0ub25jZSgnZW5kJywgcmVzb2x2ZSk7XG4gICAgemlwUmVhZFN0cmVhbS5vbmNlKCdlcnJvcicsIHJlamVjdCk7XG4gIH0pO1xuICB6aXBSZWFkU3RyZWFtLnBpcGUod3JpdGVTdHJlYW0pO1xuXG4gIC8vIFdhaXQgZm9yIHRoZSB6aXBSZWFkU3RyZWFtIGFuZCB3cml0ZVN0cmVhbSB0byBlbmQgYmVmb3JlIHJldHVybmluZ1xuICByZXR1cm4gYXdhaXQgQi5hbGwoW1xuICAgIHppcFJlYWRTdHJlYW1Qcm9taXNlLFxuICAgIHdyaXRlU3RyZWFtUHJvbWlzZSxcbiAgXSk7XG59XG5cbi8qKlxuICogQHR5cGVkZWYgWmlwRW50cnlcbiAqIEBwcm9wZXJ0eSB7eWF1emwuWmlwRW50cnl9IGVudHJ5IFRoZSBhY3R1YWwgZW50cnkgaW5zdGFuY2VcbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IGV4dHJhY3RFbnRyeVRvIEFuIGFzeW5jIGZ1bmN0aW9uLCB3aGljaCBhY2NlcHRzIG9uZSBwYXJhbWV0ZXIuXG4gKiBUaGlzIHBhcmFtZXRlciBjb250YWlucyB0aGUgZGVzdGluYXRpb24gZm9sZGVyIHBhdGggdG8gd2hpY2ggdGhpcyBmdW5jdGlvbiBpcyBnb2luZyB0byBleHRyYWN0IHRoZSBlbnRyeS5cbiAqL1xuXG4vKipcbiAqIEdldCBlbnRyaWVzIGZvciBhIHppcCBmb2xkZXJcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gemlwRmlsZVBhdGggVGhlIGZ1bGwgcGF0aCB0byB0aGUgc291cmNlIFpJUCBmaWxlXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBvbkVudHJ5IENhbGxiYWNrIHdoZW4gZW50cnkgaXMgcmVhZC5cbiAqIFRoZSBjYWxsYmFjayBpcyBleHBlY3RlZCB0byBhY2NlcHQgb25lIGFyZ3VtZW50IG9mIFppcEVudHJ5IHR5cGUuXG4gKiBUaGUgaXRlcmF0aW9uIHRocm91Z2ggdGhlIHNvdXJjZSB6aXAgZmlsZSB3aWxsIGJpIHRlcm1pbmF0ZWQgYXMgc29vbiBhc1xuICogdGhlIHJlc3VsdCBvZiB0aGlzIGZ1bmN0aW9uIGVxdWFscyB0byBgZmFsc2VgLlxuICovXG5hc3luYyBmdW5jdGlvbiByZWFkRW50cmllcyAoemlwRmlsZVBhdGgsIG9uRW50cnkpIHtcbiAgLy8gT3BlbiBhIHppcCBmaWxlIGFuZCBzdGFydCByZWFkaW5nIGVudHJpZXNcbiAgY29uc3QgemlwZmlsZSA9IGF3YWl0IG9wZW5aaXAoemlwRmlsZVBhdGgsIHtsYXp5RW50cmllczogdHJ1ZX0pO1xuICBjb25zdCB6aXBSZWFkU3RyZWFtUHJvbWlzZSA9IG5ldyBCKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICB6aXBmaWxlLm9uY2UoJ2VuZCcsIHJlc29sdmUpO1xuICAgIHppcGZpbGUub25jZSgnZXJyb3InLCByZWplY3QpO1xuXG4gICAgLy8gT24gZWFjaCBlbnRyeSwgY2FsbCAnb25FbnRyeScgYW5kIHRoZW4gcmVhZCB0aGUgbmV4dCBlbnRyeVxuICAgIHppcGZpbGUub24oJ2VudHJ5JywgYXN5bmMgKGVudHJ5KSA9PiB7XG4gICAgICBjb25zdCByZXMgPSBhd2FpdCBvbkVudHJ5KHtcbiAgICAgICAgZW50cnksXG4gICAgICAgIGV4dHJhY3RFbnRyeVRvOiBhc3luYyAoZGVzdERpcikgPT4gYXdhaXQgX2V4dHJhY3RFbnRyeVRvKHppcGZpbGUsIGVudHJ5LCBkZXN0RGlyKVxuICAgICAgfSk7XG4gICAgICBpZiAocmVzID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gemlwZmlsZS5lbWl0KCdlbmQnKTtcbiAgICAgIH1cbiAgICAgIHppcGZpbGUucmVhZEVudHJ5KCk7XG4gICAgfSk7XG4gIH0pO1xuICB6aXBmaWxlLnJlYWRFbnRyeSgpO1xuXG4gIC8vIFdhaXQgZm9yIHRoZSBlbnRyaWVzIHRvIGZpbmlzaCBiZWluZyBpdGVyYXRlZCB0aHJvdWdoXG4gIHJldHVybiBhd2FpdCB6aXBSZWFkU3RyZWFtUHJvbWlzZTtcbn1cblxuLyoqXG4gKiBAdHlwZWRlZiBaaXBPcHRpb25zXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGVuY29kZVRvQmFzZTY0IFtmYWxzZV0gV2hldGhlciB0byBlbmNvZGVcbiAqIHRoZSByZXN1bHRpbmcgYXJjaGl2ZSB0byBhIGJhc2U2NC1lbmNvZGVkIHN0cmluZ1xuICogQHByb3BlcnR5IHtib29sZWFufSBpc01ldGVyZWQgW3RydWVdIFdoZXRoZXIgdG8gbG9nIHRoZSBhY3R1YWxcbiAqIGFyY2hpdmVyIHBlcmZvcm1hbmNlXG4gKiBAcHJvcGVydHkge251bWJlcn0gbWF4U2l6ZSBbMTA3Mzc0MTgyNF0gVGhlIG1heGltdW0gc2l6ZSBvZlxuICogdGhlIHJlc3VsdGluZyBhcmNoaXZlIGluIGJ5dGVzLiBUaGlzIGlzIHNldCB0byAxR0IgYnkgZGVmYXVsdCwgYmVjYXVzZVxuICogQXBwaXVtIGxpbWl0cyB0aGUgbWF4aW11bSBIVFRQIGJvZHkgc2l6ZSB0byAxR0IuIEFsc28sIHRoZSBOb2RlSlMgaGVhcFxuICogc2l6ZSBtdXN0IGJlIGVub3VnaCB0byBrZWVwIHRoZSByZXN1bHRpbmcgb2JqZWN0ICh1c3VhbGx5IHRoaXMgc2l6ZSBpc1xuICogbGltaXRlZCB0byAxLjQgR0IpXG4gKiBAcHJvcGVydHkge251bWJlcn0gbGV2ZWwgWzldIFRoZSBjb21wcmVzc2lvbiBsZXZlbC4gVGhlIG1heGltdW1cbiAqIGxldmVsIGlzIDkgKHRoZSBiZXN0IGNvbXByZXNzaW9uLCB3b3JzdCBwZXJmb3JtYW5jZSkuIFRoZSBtaW5pbXVtXG4gKiBjb21wcmVzc2lvbiBsZXZlbCBpcyAwIChubyBjb21wcmVzc2lvbikuXG4gKi9cblxuLyoqXG4gKiBDb252ZXJ0cyBjb250ZW50cyBvZiBsb2NhbCBkaXJlY3RvcnkgdG8gYW4gaW4tbWVtb3J5IC56aXAgYnVmZmVyXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHNyY1BhdGggVGhlIGZ1bGwgcGF0aCB0byB0aGUgZm9sZGVyIG9yIGZpbGUgYmVpbmcgemlwcGVkXG4gKiBAcGFyYW0ge1ppcE9wdGlvbnN9IG9wdHMgWmlwcGluZyBvcHRpb25zXG4gKiBAcmV0dXJucyB7QnVmZmVyfSBaaXBwZWQgKGFuZCBlbmNvZGVkIGlmIGBlbmNvZGVUb0Jhc2U2NGAgaXMgdHJ1dGh5KVxuICogY29udGVudCBvZiB0aGUgc291cmNlIHBhdGggYXMgbWVtb3J5IGJ1ZmZlclxuICogQHRocm93cyB7RXJyb3J9IGlmIHRoZXJlIHdhcyBhbiBlcnJvciB3aGlsZSByZWFkaW5nIHRoZSBzb3VyY2VcbiAqIG9yIHRoZSBzb3VyY2UgaXMgdG9vIGJpZ1xuICovXG5hc3luYyBmdW5jdGlvbiB0b0luTWVtb3J5WmlwIChzcmNQYXRoLCBvcHRzID0ge30pIHtcbiAgaWYgKCFhd2FpdCBmcy5leGlzdHMoc3JjUGF0aCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIHN1Y2ggZmlsZSBvciBmb2xkZXI6ICR7c3JjUGF0aH1gKTtcbiAgfVxuXG4gIGNvbnN0IHtcbiAgICBpc01ldGVyZWQgPSB0cnVlLFxuICAgIGVuY29kZVRvQmFzZTY0ID0gZmFsc2UsXG4gICAgbWF4U2l6ZSA9IDEgKiBHaUIsXG4gICAgbGV2ZWwgPSA5LFxuICB9ID0gb3B0cztcbiAgY29uc3QgcmVzdWx0QnVmZmVycyA9IFtdO1xuICBsZXQgcmVzdWx0QnVmZmVyc1NpemUgPSAwO1xuICAvLyBDcmVhdGUgYSB3cml0YWJsZSBzdHJlYW0gdGhhdCB6aXAgYnVmZmVycyB3aWxsIGJlIHN0cmVhbWVkIHRvXG4gIGNvbnN0IHJlc3VsdFdyaXRlU3RyZWFtID0gbmV3IHN0cmVhbS5Xcml0YWJsZSh7XG4gICAgd3JpdGU6IChidWZmZXIsIGVuY29kaW5nLCBuZXh0KSA9PiB7XG4gICAgICByZXN1bHRCdWZmZXJzLnB1c2goYnVmZmVyKTtcbiAgICAgIHJlc3VsdEJ1ZmZlcnNTaXplICs9IGJ1ZmZlci5sZW5ndGg7XG4gICAgICBpZiAobWF4U2l6ZSA+IDAgJiYgcmVzdWx0QnVmZmVyc1NpemUgPiBtYXhTaXplKSB7XG4gICAgICAgIHJlc3VsdFdyaXRlU3RyZWFtLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKGBUaGUgc2l6ZSBvZiB0aGUgcmVzdWx0aW5nIGAgK1xuICAgICAgICAgIGBhcmNoaXZlIG11c3Qgbm90IGJlIGdyZWF0ZXIgdGhhbiAke3RvUmVhZGFibGVTaXplU3RyaW5nKG1heFNpemUpfWApKTtcbiAgICAgIH1cbiAgICAgIG5leHQoKTtcbiAgICB9LFxuICB9KTtcblxuICAvLyBaaXAgJ3NyY0RpcicgYW5kIHN0cmVhbSBpdCB0byB0aGUgYWJvdmUgd3JpdGFibGUgc3RyZWFtXG4gIGNvbnN0IGFyY2hpdmUgPSBhcmNoaXZlcignemlwJywge1xuICAgIHpsaWI6IHtsZXZlbH1cbiAgfSk7XG4gIGxldCBzcmNTaXplID0gbnVsbDtcbiAgY29uc3QgYmFzZTY0RW5jb2RlclN0cmVhbSA9IGVuY29kZVRvQmFzZTY0ID8gbmV3IEJhc2U2NEVuY29kZSgpIDogbnVsbDtcbiAgY29uc3QgcmVzdWx0V3JpdGVTdHJlYW1Qcm9taXNlID0gbmV3IEIoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIHJlc3VsdFdyaXRlU3RyZWFtLm9uY2UoJ2Vycm9yJywgKGUpID0+IHtcbiAgICAgIGlmIChiYXNlNjRFbmNvZGVyU3RyZWFtKSB7XG4gICAgICAgIGFyY2hpdmUudW5waXBlKGJhc2U2NEVuY29kZXJTdHJlYW0pO1xuICAgICAgICBiYXNlNjRFbmNvZGVyU3RyZWFtLnVucGlwZShyZXN1bHRXcml0ZVN0cmVhbSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhcmNoaXZlLnVucGlwZShyZXN1bHRXcml0ZVN0cmVhbSk7XG4gICAgICB9XG4gICAgICBhcmNoaXZlLmFib3J0KCk7XG4gICAgICBhcmNoaXZlLmRlc3Ryb3koKTtcbiAgICAgIHJlamVjdChlKTtcbiAgICB9KTtcbiAgICByZXN1bHRXcml0ZVN0cmVhbS5vbmNlKCdmaW5pc2gnLCAoKSA9PiB7XG4gICAgICBzcmNTaXplID0gYXJjaGl2ZS5wb2ludGVyKCk7XG4gICAgICByZXNvbHZlKCk7XG4gICAgfSk7XG4gIH0pO1xuICBjb25zdCBhcmNoaXZlU3RyZWFtUHJvbWlzZSA9IG5ldyBCKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBhcmNoaXZlLm9uY2UoJ2ZpbmlzaCcsIHJlc29sdmUpO1xuICAgIGFyY2hpdmUub25jZSgnZXJyb3InLCAoZSkgPT4gcmVqZWN0KFxuICAgICAgbmV3IEVycm9yKGBGYWlsZWQgdG8gYXJjaGl2ZSAnJHtzcmNQYXRofSc6ICR7ZS5tZXNzYWdlfWApKSk7XG4gIH0pO1xuICBjb25zdCB0aW1lciA9IGlzTWV0ZXJlZCA/IG5ldyBUaW1lcigpLnN0YXJ0KCkgOiBudWxsO1xuICBpZiAoKGF3YWl0IGZzLnN0YXQoc3JjUGF0aCkpLmlzRGlyZWN0b3J5KCkpIHtcbiAgICBhcmNoaXZlLmRpcmVjdG9yeShzcmNQYXRoLCBmYWxzZSk7XG4gIH0gZWxzZSB7XG4gICAgYXJjaGl2ZS5maWxlKHNyY1BhdGgsIHtcbiAgICAgIG5hbWU6IHBhdGguYmFzZW5hbWUoc3JjUGF0aCksXG4gICAgfSk7XG4gIH1cbiAgaWYgKGJhc2U2NEVuY29kZXJTdHJlYW0pIHtcbiAgICBhcmNoaXZlLnBpcGUoYmFzZTY0RW5jb2RlclN0cmVhbSk7XG4gICAgYmFzZTY0RW5jb2RlclN0cmVhbS5waXBlKHJlc3VsdFdyaXRlU3RyZWFtKTtcbiAgfSBlbHNlIHtcbiAgICBhcmNoaXZlLnBpcGUocmVzdWx0V3JpdGVTdHJlYW0pO1xuICB9XG4gIGFyY2hpdmUuZmluYWxpemUoKTtcblxuICAvLyBXYWl0IGZvciB0aGUgc3RyZWFtcyB0byBmaW5pc2hcbiAgYXdhaXQgQi5hbGwoW2FyY2hpdmVTdHJlYW1Qcm9taXNlLCByZXN1bHRXcml0ZVN0cmVhbVByb21pc2VdKTtcblxuICBpZiAodGltZXIpIHtcbiAgICBsb2cuZGVidWcoYFppcHBlZCAke2VuY29kZVRvQmFzZTY0ID8gJ2FuZCBiYXNlNjQtZW5jb2RlZCAnIDogJyd9YCArXG4gICAgICBgJyR7cGF0aC5iYXNlbmFtZShzcmNQYXRoKX0nIGAgK1xuICAgICAgKHNyY1NpemUgPyBgKCR7dG9SZWFkYWJsZVNpemVTdHJpbmcoc3JjU2l6ZSl9KSBgIDogJycpICtcbiAgICAgIGBpbiAke3RpbWVyLmdldER1cmF0aW9uKCkuYXNTZWNvbmRzLnRvRml4ZWQoMyl9cyBgICtcbiAgICAgIGAoY29tcHJlc3Npb24gbGV2ZWw6ICR7bGV2ZWx9KWApO1xuICB9XG4gIC8vIFJldHVybiB0aGUgYXJyYXkgb2YgemlwIGJ1ZmZlcnMgY29uY2F0ZW5hdGVkIGludG8gb25lIGJ1ZmZlclxuICByZXR1cm4gQnVmZmVyLmNvbmNhdChyZXN1bHRCdWZmZXJzKTtcbn1cblxuLyoqXG4gKiBWZXJpZmllcyB3aGV0aGVyIHRoZSBnaXZlbiBmaWxlIGlzIGEgdmFsaWQgWklQIGFyY2hpdmVcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZmlsZVBhdGggLSBGdWxsIHBhdGggdG8gdGhlIGZpbGVcbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgZmlsZSBkb2VzIG5vdCBleGlzdCBvciBpcyBub3QgYSB2YWxpZCBaSVAgYXJjaGl2ZVxuICovXG5hc3luYyBmdW5jdGlvbiBhc3NlcnRWYWxpZFppcCAoZmlsZVBhdGgpIHtcbiAgaWYgKCFhd2FpdCBmcy5leGlzdHMoZmlsZVBhdGgpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgZmlsZSBhdCAnJHtmaWxlUGF0aH0nIGRvZXMgbm90IGV4aXN0YCk7XG4gIH1cblxuICBjb25zdCB7c2l6ZX0gPSBhd2FpdCBmcy5zdGF0KGZpbGVQYXRoKTtcbiAgaWYgKHNpemUgPCA0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgZmlsZSBhdCAnJHtmaWxlUGF0aH0nIGlzIHRvbyBzbWFsbCB0byBiZSBhIFpJUCBhcmNoaXZlYCk7XG4gIH1cbiAgY29uc3QgZmQgPSBhd2FpdCBmcy5vcGVuKGZpbGVQYXRoLCAncicpO1xuICB0cnkge1xuICAgIGNvbnN0IGJ1ZmZlciA9IEJ1ZmZlci5hbGxvYyhaSVBfTUFHSUMubGVuZ3RoKTtcbiAgICBhd2FpdCBmcy5yZWFkKGZkLCBidWZmZXIsIDAsIFpJUF9NQUdJQy5sZW5ndGgsIDApO1xuICAgIGNvbnN0IHNpZ25hdHVyZSA9IGJ1ZmZlci50b1N0cmluZygnYXNjaWknKTtcbiAgICBpZiAoc2lnbmF0dXJlICE9PSBaSVBfTUFHSUMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIGZpbGUgc2lnbmF0dXJlICcke3NpZ25hdHVyZX0nIG9mICcke2ZpbGVQYXRofScgYCArXG4gICAgICAgIGBpcyBub3QgZXF1YWwgdG8gdGhlIGV4cGVjdGVkIFpJUCBhcmNoaXZlIHNpZ25hdHVyZSAnJHtaSVBfTUFHSUN9J2ApO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBmaW5hbGx5IHtcbiAgICBhd2FpdCBmcy5jbG9zZShmZCk7XG4gIH1cbn1cblxuLyoqXG4gKiBAdHlwZWRlZiBaaXBDb21wcmVzc2lvbk9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBsZXZlbCBbOV0gLSBDb21wcmVzc2lvbiBsZXZlbCBpbiByYW5nZSAwLi45XG4gKiAoZ3JlYXRlciBudW1iZXJzIG1lYW4gYmV0dGVyIGNvbXByZXNzaW9uLCBidXQgbG9uZ2VyIHByb2Nlc3NpbmcgdGltZSlcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIFppcFNvdXJjZU9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7IXN0cmluZ30gcGF0dGVybiBbJyoqXFwvKiddIC0gR0xPQiBwYXR0ZXJuIGZvciBjb21wcmVzc2lvblxuICogQHByb3BlcnR5IHshc3RyaW5nfSBjd2QgLSBUaGUgc291cmNlIHJvb3QgZm9sZGVyICh0aGUgcGFyZW50IGZvbGRlciBvZlxuICogdGhlIGRlc3RpbmF0aW9uIGZpbGUgYnkgZGVmYXVsdClcbiAqIEBwcm9wZXJ0eSB7P0FycmF5PHN0cmluZz59IGlnbm9yZSAtIFRoZSBsaXN0IG9mIGlnbm9yZWQgcGF0dGVybnNcbiAqL1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJjaGl2ZSBiYXNlZCBvbiB0aGUgZ2l2ZW4gZ2xvYiBwYXR0ZXJuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGRzdFBhdGggLSBUaGUgcmVzdWx0aW5nIGFyY2hpdmUgcGF0aFxuICogQHBhcmFtIHtaaXBTb3VyY2VPcHRpb25zfSBzcmMgLSBTb3VyY2Ugb3B0aW9uc1xuICogQHBhcmFtIHtaaXBDb21wcmVzc2lvbk9wdGlvbnN9IG9wdHMgLSBDb21wcmVzc2lvbiBvcHRpb25zXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlcmUgd2FzIGFuIGVycm9yIHdoaWxlIGNyZWF0aW5nIHRoZSBhcmNoaXZlXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHRvQXJjaGl2ZSAoZHN0UGF0aCwgc3JjID0ge30sIG9wdHMgPSB7fSkge1xuICBjb25zdCB7XG4gICAgbGV2ZWwgPSA5LFxuICB9ID0gb3B0cztcbiAgY29uc3Qge1xuICAgIHBhdHRlcm4gPSAnKiovKicsXG4gICAgY3dkID0gcGF0aC5kaXJuYW1lKGRzdFBhdGgpLFxuICAgIGlnbm9yZSA9IFtdLFxuICB9ID0gc3JjO1xuICBjb25zdCBhcmNoaXZlID0gYXJjaGl2ZXIoJ3ppcCcsIHsgemxpYjogeyBsZXZlbCB9fSk7XG4gIGNvbnN0IHN0cmVhbSA9IGZzLmNyZWF0ZVdyaXRlU3RyZWFtKGRzdFBhdGgpO1xuICByZXR1cm4gYXdhaXQgbmV3IEIoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGFyY2hpdmVcbiAgICAgIC5nbG9iKHBhdHRlcm4sIHtcbiAgICAgICAgY3dkLFxuICAgICAgICBpZ25vcmUsXG4gICAgICB9KVxuICAgICAgLm9uKCdlcnJvcicsIHJlamVjdClcbiAgICAgIC5waXBlKHN0cmVhbSk7XG4gICAgc3RyZWFtXG4gICAgICAub24oJ2Vycm9yJywgKGUpID0+IHtcbiAgICAgICAgYXJjaGl2ZS51bnBpcGUoc3RyZWFtKTtcbiAgICAgICAgYXJjaGl2ZS5hYm9ydCgpO1xuICAgICAgICBhcmNoaXZlLmRlc3Ryb3koKTtcbiAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgfSlcbiAgICAgIC5vbignZmluaXNoJywgcmVzb2x2ZSk7XG4gICAgYXJjaGl2ZS5maW5hbGl6ZSgpO1xuICB9KTtcbn1cblxuLyoqXG4gKiBGaW5kcyBhbmQgbWVtb2l6ZXMgdGhlIGZ1bGwgcGF0aCB0byB0aGUgZ2l2ZW4gZXhlY3V0YWJsZS5cbiAqIFJlamVjdHMgaWYgaXQgaXMgbm90IGZvdW5kLlxuICovXG5jb25zdCBnZXRFeGVjdXRhYmxlUGF0aCA9IF8ubWVtb2l6ZShcbiAgLyoqXG4gICAqIEByZXR1cm5zIHtCPHN0cmluZz59IEZ1bGwgUGF0aCB0byB0aGUgZXhlY3V0YWJsZVxuICAgKi9cbiAgYXN5bmMgZnVuY3Rpb24gZ2V0RXhlY3V0YWJsZVBhdGggKGJpbmFyeU5hbWUpIHtcbiAgICBjb25zdCBmdWxsUGF0aCA9IGF3YWl0IGZzLndoaWNoKGJpbmFyeU5hbWUpO1xuICAgIGxvZy5kZWJ1ZyhgRm91bmQgJyVzJyBhdCAnJXMnYCwgYmluYXJ5TmFtZSwgZnVsbFBhdGgpO1xuICAgIHJldHVybiBmdWxsUGF0aDtcbiAgfVxuKTtcblxuZXhwb3J0IHsgZXh0cmFjdEFsbFRvLCByZWFkRW50cmllcywgdG9Jbk1lbW9yeVppcCwgX2V4dHJhY3RFbnRyeVRvLFxuICBhc3NlcnRWYWxpZFppcCwgdG9BcmNoaXZlIH07XG5leHBvcnQgZGVmYXVsdCB7IGV4dHJhY3RBbGxUbywgcmVhZEVudHJpZXMsIHRvSW5NZW1vcnlaaXAsIGFzc2VydFZhbGlkWmlwLCB0b0FyY2hpdmUgfTtcbiJdfQ==