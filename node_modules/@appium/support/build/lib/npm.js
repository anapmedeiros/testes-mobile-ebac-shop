"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.npm = exports.NPM = exports.LINK_LOCKFILE_RELATIVE_PATH = exports.INSTALL_LOCKFILE_RELATIVE_PATH = exports.CACHE_DIR_RELATIVE_PATH = void 0;

require("source-map-support/register");

var _path = _interopRequireDefault(require("path"));

var _semver = _interopRequireDefault(require("semver"));

var _teen_process = require("teen_process");

var _fs = require("./fs");

var util = _interopRequireWildcard(require("./util"));

var system = _interopRequireWildcard(require("./system"));

var _resolveFrom = _interopRequireDefault(require("resolve-from"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const CACHE_DIR_RELATIVE_PATH = _path.default.join('node_modules', '.cache', 'appium');

exports.CACHE_DIR_RELATIVE_PATH = CACHE_DIR_RELATIVE_PATH;

const INSTALL_LOCKFILE_RELATIVE_PATH = _path.default.join(CACHE_DIR_RELATIVE_PATH, '.install.lock');

exports.INSTALL_LOCKFILE_RELATIVE_PATH = INSTALL_LOCKFILE_RELATIVE_PATH;

const LINK_LOCKFILE_RELATIVE_PATH = _path.default.join(CACHE_DIR_RELATIVE_PATH, '.link.lock');

exports.LINK_LOCKFILE_RELATIVE_PATH = LINK_LOCKFILE_RELATIVE_PATH;

class NPM {
  _getInstallLockfilePath(cwd) {
    return _path.default.join(cwd, INSTALL_LOCKFILE_RELATIVE_PATH);
  }

  _getLinkLockfilePath(cwd) {
    return _path.default.join(cwd, LINK_LOCKFILE_RELATIVE_PATH);
  }

  async exec(cmd, args, opts, execOpts = {}) {
    let {
      cwd,
      json,
      lockFile
    } = opts;
    execOpts = { ...execOpts,
      cwd
    };
    args.unshift(cmd);

    if (json) {
      args.push('--json');
    }

    const npmCmd = system.isWindows() ? 'npm.cmd' : 'npm';

    let runner = async () => await (0, _teen_process.exec)(npmCmd, args, execOpts);

    if (lockFile) {
      const acquireLock = util.getLockFileGuard(lockFile);
      const _runner = runner;

      runner = async () => await acquireLock(_runner);
    }

    let ret;

    try {
      const {
        stdout,
        stderr,
        code
      } = await runner();
      ret = {
        stdout,
        stderr,
        code
      };

      try {
        ret.json = JSON.parse(stdout);
      } catch (ign) {}
    } catch (e) {
      const {
        stdout = '',
        stderr = '',
        code = null
      } = e;
      const err = new Error(`npm command '${args.join(' ')}' failed with code ${code}.\n\nSTDOUT:\n${stdout.trim()}\n\nSTDERR:\n${stderr.trim()}`);
      throw err;
    }

    return ret;
  }

  async getLatestVersion(cwd, pkg) {
    var _await$this$exec$json;

    return (_await$this$exec$json = (await this.exec('view', [pkg, 'dist-tags'], {
      json: true,
      cwd
    })).json) === null || _await$this$exec$json === void 0 ? void 0 : _await$this$exec$json.latest;
  }

  async getLatestSafeUpgradeVersion(cwd, pkg, curVersion) {
    const allVersions = (await this.exec('view', [pkg, 'versions'], {
      json: true,
      cwd
    })).json;
    return this.getLatestSafeUpgradeFromVersions(curVersion, allVersions);
  }

  async list(cwd, pkg) {
    return (await this.exec('list', pkg ? [pkg] : [], {
      cwd,
      json: true
    })).json;
  }

  getLatestSafeUpgradeFromVersions(curVersion, allVersions) {
    let safeUpgradeVer = null;

    const curSemver = _semver.default.parse(curVersion);

    if (curSemver === null) {
      throw new Error(`Could not parse current version '${curVersion}'`);
    }

    for (const testVer of allVersions) {
      const testSemver = _semver.default.parse(testVer);

      if (testSemver === null) {
        throw new Error(`Could not parse version to test against: '${testVer}'`);
      }

      if (testSemver.prerelease.length > 0) {
        continue;
      }

      if (curSemver.compare(testSemver) === 1) {
        continue;
      }

      if (testSemver.major > curSemver.major) {
        continue;
      }

      if (safeUpgradeVer === null || testSemver.compare(safeUpgradeVer) === 1) {
        safeUpgradeVer = testSemver;
      }
    }

    if (safeUpgradeVer) {
      safeUpgradeVer = safeUpgradeVer.format();
    }

    return safeUpgradeVer;
  }

  async installPackage(cwd, pkgName, {
    pkgVer
  } = {}) {
    const dummyPkgJson = _path.default.resolve(cwd, 'package.json');

    if (!(await _fs.fs.exists(dummyPkgJson))) {
      await _fs.fs.writeFile(dummyPkgJson, '{}');
    }

    const res = await this.exec('install', ['--no-save', '--global-style', '--no-package-lock', pkgVer ? `${pkgName}@${pkgVer}` : pkgName], {
      cwd,
      json: true,
      lockFile: this._getInstallLockfilePath(cwd)
    });

    if (res.json) {
      if (res.json.error) {
        throw new Error(res.json.error);
      }
    }

    const pkgJsonPath = (0, _resolveFrom.default)(cwd, `${pkgName}/package.json`);

    try {
      return require(pkgJsonPath);
    } catch {
      throw new Error('The package was not downloaded correctly; its package.json ' + 'did not exist or was unreadable. We looked for it at ' + pkgJsonPath);
    }
  }

  async linkPackage(cwd, pkgPath) {
    let pkgName;

    try {
      pkgName = require(_path.default.resolve(pkgPath, 'package.json')).name;
    } catch {
      throw new Error('Could not find package.json inside the package path ' + `provided: ${pkgPath}`);
    }

    pkgPath = _path.default.resolve(process.cwd(), pkgPath);
    const args = ['--global-style', '--no-package-lock', pkgPath];
    const res = await this.exec('link', args, {
      cwd,
      lockFile: this._getLinkLockfilePath(cwd)
    });

    if (res.json && res.json.error) {
      throw new Error(res.json.error);
    }

    try {
      return require((0, _resolveFrom.default)(cwd, `${pkgName}/package.json`));
    } catch {
      throw new Error('The package was not linked correctly; its package.json ' + 'did not exist or was unreadable');
    }
  }

  async uninstallPackage(cwd, pkg) {
    await this.exec('uninstall', [pkg], {
      cwd,
      lockFile: this._getInstallLockfilePath(cwd)
    });
  }

}

exports.NPM = NPM;
const npm = new NPM();
exports.npm = npm;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL2xpYi9ucG0uanMiXSwibmFtZXMiOlsiQ0FDSEVfRElSX1JFTEFUSVZFX1BBVEgiLCJwYXRoIiwiam9pbiIsIklOU1RBTExfTE9DS0ZJTEVfUkVMQVRJVkVfUEFUSCIsIkxJTktfTE9DS0ZJTEVfUkVMQVRJVkVfUEFUSCIsIk5QTSIsIl9nZXRJbnN0YWxsTG9ja2ZpbGVQYXRoIiwiY3dkIiwiX2dldExpbmtMb2NrZmlsZVBhdGgiLCJleGVjIiwiY21kIiwiYXJncyIsIm9wdHMiLCJleGVjT3B0cyIsImpzb24iLCJsb2NrRmlsZSIsInVuc2hpZnQiLCJwdXNoIiwibnBtQ21kIiwic3lzdGVtIiwiaXNXaW5kb3dzIiwicnVubmVyIiwiYWNxdWlyZUxvY2siLCJ1dGlsIiwiZ2V0TG9ja0ZpbGVHdWFyZCIsIl9ydW5uZXIiLCJyZXQiLCJzdGRvdXQiLCJzdGRlcnIiLCJjb2RlIiwiSlNPTiIsInBhcnNlIiwiaWduIiwiZSIsImVyciIsIkVycm9yIiwidHJpbSIsImdldExhdGVzdFZlcnNpb24iLCJwa2ciLCJsYXRlc3QiLCJnZXRMYXRlc3RTYWZlVXBncmFkZVZlcnNpb24iLCJjdXJWZXJzaW9uIiwiYWxsVmVyc2lvbnMiLCJnZXRMYXRlc3RTYWZlVXBncmFkZUZyb21WZXJzaW9ucyIsImxpc3QiLCJzYWZlVXBncmFkZVZlciIsImN1clNlbXZlciIsInNlbXZlciIsInRlc3RWZXIiLCJ0ZXN0U2VtdmVyIiwicHJlcmVsZWFzZSIsImxlbmd0aCIsImNvbXBhcmUiLCJtYWpvciIsImZvcm1hdCIsImluc3RhbGxQYWNrYWdlIiwicGtnTmFtZSIsInBrZ1ZlciIsImR1bW15UGtnSnNvbiIsInJlc29sdmUiLCJmcyIsImV4aXN0cyIsIndyaXRlRmlsZSIsInJlcyIsImVycm9yIiwicGtnSnNvblBhdGgiLCJyZXF1aXJlIiwibGlua1BhY2thZ2UiLCJwa2dQYXRoIiwibmFtZSIsInByb2Nlc3MiLCJ1bmluc3RhbGxQYWNrYWdlIiwibnBtIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUVBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOzs7Ozs7QUFPTyxNQUFNQSx1QkFBdUIsR0FBR0MsY0FBS0MsSUFBTCxDQUNyQyxjQURxQyxFQUVyQyxRQUZxQyxFQUdyQyxRQUhxQyxDQUFoQzs7OztBQVNBLE1BQU1DLDhCQUE4QixHQUFHRixjQUFLQyxJQUFMLENBQzVDRix1QkFENEMsRUFFNUMsZUFGNEMsQ0FBdkM7Ozs7QUFRQSxNQUFNSSwyQkFBMkIsR0FBR0gsY0FBS0MsSUFBTCxDQUN6Q0YsdUJBRHlDLEVBRXpDLFlBRnlDLENBQXBDOzs7O0FBUUEsTUFBTUssR0FBTixDQUFVO0FBTWZDLEVBQUFBLHVCQUF1QixDQUFFQyxHQUFGLEVBQU87QUFDNUIsV0FBT04sY0FBS0MsSUFBTCxDQUFVSyxHQUFWLEVBQWVKLDhCQUFmLENBQVA7QUFDRDs7QUFPREssRUFBQUEsb0JBQW9CLENBQUVELEdBQUYsRUFBTztBQUN6QixXQUFPTixjQUFLQyxJQUFMLENBQVVLLEdBQVYsRUFBZUgsMkJBQWYsQ0FBUDtBQUNEOztBQVlTLFFBQUpLLElBQUksQ0FBRUMsR0FBRixFQUFPQyxJQUFQLEVBQWFDLElBQWIsRUFBbUJDLFFBQVEsR0FBRyxFQUE5QixFQUFrQztBQUMxQyxRQUFJO0FBQUVOLE1BQUFBLEdBQUY7QUFBT08sTUFBQUEsSUFBUDtBQUFhQyxNQUFBQTtBQUFiLFFBQTBCSCxJQUE5QjtBQUdBQyxJQUFBQSxRQUFRLEdBQUcsRUFBQyxHQUFHQSxRQUFKO0FBQWNOLE1BQUFBO0FBQWQsS0FBWDtBQUVBSSxJQUFBQSxJQUFJLENBQUNLLE9BQUwsQ0FBYU4sR0FBYjs7QUFDQSxRQUFJSSxJQUFKLEVBQVU7QUFDUkgsTUFBQUEsSUFBSSxDQUFDTSxJQUFMLENBQVUsUUFBVjtBQUNEOztBQUNELFVBQU1DLE1BQU0sR0FBR0MsTUFBTSxDQUFDQyxTQUFQLEtBQXFCLFNBQXJCLEdBQWlDLEtBQWhEOztBQUNBLFFBQUlDLE1BQU0sR0FBRyxZQUFZLE1BQU0sd0JBQUtILE1BQUwsRUFBYVAsSUFBYixFQUFtQkUsUUFBbkIsQ0FBL0I7O0FBQ0EsUUFBSUUsUUFBSixFQUFjO0FBQ1osWUFBTU8sV0FBVyxHQUFHQyxJQUFJLENBQUNDLGdCQUFMLENBQXNCVCxRQUF0QixDQUFwQjtBQUNBLFlBQU1VLE9BQU8sR0FBR0osTUFBaEI7O0FBQ0FBLE1BQUFBLE1BQU0sR0FBRyxZQUFZLE1BQU1DLFdBQVcsQ0FBQ0csT0FBRCxDQUF0QztBQUNEOztBQUVELFFBQUlDLEdBQUo7O0FBQ0EsUUFBSTtBQUNGLFlBQU07QUFBQ0MsUUFBQUEsTUFBRDtBQUFTQyxRQUFBQSxNQUFUO0FBQWlCQyxRQUFBQTtBQUFqQixVQUF5QixNQUFNUixNQUFNLEVBQTNDO0FBQ0FLLE1BQUFBLEdBQUcsR0FBd0M7QUFBQ0MsUUFBQUEsTUFBRDtBQUFTQyxRQUFBQSxNQUFUO0FBQWlCQyxRQUFBQTtBQUFqQixPQUEzQzs7QUFJQSxVQUFJO0FBQ0ZILFFBQUFBLEdBQUcsQ0FBQ1osSUFBSixHQUFXZ0IsSUFBSSxDQUFDQyxLQUFMLENBQVdKLE1BQVgsQ0FBWDtBQUNELE9BRkQsQ0FFRSxPQUFPSyxHQUFQLEVBQVksQ0FBRTtBQUNqQixLQVRELENBU0UsT0FBT0MsQ0FBUCxFQUFVO0FBQ1YsWUFBTTtBQUFDTixRQUFBQSxNQUFNLEdBQUcsRUFBVjtBQUFjQyxRQUFBQSxNQUFNLEdBQUcsRUFBdkI7QUFBMkJDLFFBQUFBLElBQUksR0FBRztBQUFsQyxVQUE4RUksQ0FBcEY7QUFDQSxZQUFNQyxHQUFHLEdBQUcsSUFBSUMsS0FBSixDQUFXLGdCQUFleEIsSUFBSSxDQUFDVCxJQUFMLENBQVUsR0FBVixDQUFlLHNCQUFxQjJCLElBQUssaUJBQWdCRixNQUFNLENBQUNTLElBQVAsRUFBYyxnQkFBZVIsTUFBTSxDQUFDUSxJQUFQLEVBQWMsRUFBOUgsQ0FBWjtBQUNBLFlBQU1GLEdBQU47QUFDRDs7QUFDRCxXQUFPUixHQUFQO0FBQ0Q7O0FBTXFCLFFBQWhCVyxnQkFBZ0IsQ0FBRTlCLEdBQUYsRUFBTytCLEdBQVAsRUFBWTtBQUFBOztBQUNoQyxvQ0FBTyxDQUFDLE1BQU0sS0FBSzdCLElBQUwsQ0FBVSxNQUFWLEVBQWtCLENBQUM2QixHQUFELEVBQU0sV0FBTixDQUFsQixFQUFzQztBQUNsRHhCLE1BQUFBLElBQUksRUFBRSxJQUQ0QztBQUVsRFAsTUFBQUE7QUFGa0QsS0FBdEMsQ0FBUCxFQUdITyxJQUhKLDBEQUFPLHNCQUdHeUIsTUFIVjtBQUlEOztBQU9nQyxRQUEzQkMsMkJBQTJCLENBQUVqQyxHQUFGLEVBQU8rQixHQUFQLEVBQVlHLFVBQVosRUFBd0I7QUFDdkQsVUFBTUMsV0FBVyxHQUFHLENBQUMsTUFBTSxLQUFLakMsSUFBTCxDQUFVLE1BQVYsRUFBa0IsQ0FBQzZCLEdBQUQsRUFBTSxVQUFOLENBQWxCLEVBQXFDO0FBQzlEeEIsTUFBQUEsSUFBSSxFQUFFLElBRHdEO0FBRTlEUCxNQUFBQTtBQUY4RCxLQUFyQyxDQUFQLEVBR2hCTyxJQUhKO0FBSUEsV0FBTyxLQUFLNkIsZ0NBQUwsQ0FBc0NGLFVBQXRDLEVBQWtEQyxXQUFsRCxDQUFQO0FBQ0Q7O0FBT1MsUUFBSkUsSUFBSSxDQUFFckMsR0FBRixFQUFPK0IsR0FBUCxFQUFZO0FBQ3BCLFdBQU8sQ0FBQyxNQUFNLEtBQUs3QixJQUFMLENBQVUsTUFBVixFQUFrQjZCLEdBQUcsR0FBRyxDQUFDQSxHQUFELENBQUgsR0FBVyxFQUFoQyxFQUFvQztBQUFDL0IsTUFBQUEsR0FBRDtBQUFNTyxNQUFBQSxJQUFJLEVBQUU7QUFBWixLQUFwQyxDQUFQLEVBQStEQSxJQUF0RTtBQUNEOztBQVlENkIsRUFBQUEsZ0NBQWdDLENBQUVGLFVBQUYsRUFBY0MsV0FBZCxFQUEyQjtBQUN6RCxRQUFJRyxjQUFjLEdBQUcsSUFBckI7O0FBQ0EsVUFBTUMsU0FBUyxHQUFHQyxnQkFBT2hCLEtBQVAsQ0FBYVUsVUFBYixDQUFsQjs7QUFDQSxRQUFJSyxTQUFTLEtBQUssSUFBbEIsRUFBd0I7QUFDdEIsWUFBTSxJQUFJWCxLQUFKLENBQVcsb0NBQW1DTSxVQUFXLEdBQXpELENBQU47QUFDRDs7QUFDRCxTQUFLLE1BQU1PLE9BQVgsSUFBc0JOLFdBQXRCLEVBQW1DO0FBQ2pDLFlBQU1PLFVBQVUsR0FBR0YsZ0JBQU9oQixLQUFQLENBQWFpQixPQUFiLENBQW5COztBQUNBLFVBQUlDLFVBQVUsS0FBSyxJQUFuQixFQUF5QjtBQUN2QixjQUFNLElBQUlkLEtBQUosQ0FBVyw2Q0FBNENhLE9BQVEsR0FBL0QsQ0FBTjtBQUNEOztBQUVELFVBQUlDLFVBQVUsQ0FBQ0MsVUFBWCxDQUFzQkMsTUFBdEIsR0FBK0IsQ0FBbkMsRUFBc0M7QUFDcEM7QUFDRDs7QUFFRCxVQUFJTCxTQUFTLENBQUNNLE9BQVYsQ0FBa0JILFVBQWxCLE1BQWtDLENBQXRDLEVBQXlDO0FBQ3ZDO0FBQ0Q7O0FBRUQsVUFBSUEsVUFBVSxDQUFDSSxLQUFYLEdBQW1CUCxTQUFTLENBQUNPLEtBQWpDLEVBQXdDO0FBQ3RDO0FBQ0Q7O0FBR0QsVUFBSVIsY0FBYyxLQUFLLElBQW5CLElBQTJCSSxVQUFVLENBQUNHLE9BQVgsQ0FBbUJQLGNBQW5CLE1BQXVDLENBQXRFLEVBQXlFO0FBQ3ZFQSxRQUFBQSxjQUFjLEdBQUdJLFVBQWpCO0FBQ0Q7QUFDRjs7QUFDRCxRQUFJSixjQUFKLEVBQW9CO0FBQ2xCQSxNQUFBQSxjQUFjLEdBQUdBLGNBQWMsQ0FBQ1MsTUFBZixFQUFqQjtBQUNEOztBQUNELFdBQU9ULGNBQVA7QUFDRDs7QUFTbUIsUUFBZFUsY0FBYyxDQUFFaEQsR0FBRixFQUFPaUQsT0FBUCxFQUFnQjtBQUFDQyxJQUFBQTtBQUFELE1BQVcsRUFBM0IsRUFBK0I7QUFJakQsVUFBTUMsWUFBWSxHQUFHekQsY0FBSzBELE9BQUwsQ0FBYXBELEdBQWIsRUFBa0IsY0FBbEIsQ0FBckI7O0FBQ0EsUUFBSSxFQUFDLE1BQU1xRCxPQUFHQyxNQUFILENBQVVILFlBQVYsQ0FBUCxDQUFKLEVBQW9DO0FBQ2xDLFlBQU1FLE9BQUdFLFNBQUgsQ0FBYUosWUFBYixFQUEyQixJQUEzQixDQUFOO0FBQ0Q7O0FBRUQsVUFBTUssR0FBRyxHQUFHLE1BQU0sS0FBS3RELElBQUwsQ0FBVSxTQUFWLEVBQXFCLENBQ3JDLFdBRHFDLEVBRXJDLGdCQUZxQyxFQUdyQyxtQkFIcUMsRUFJckNnRCxNQUFNLEdBQUksR0FBRUQsT0FBUSxJQUFHQyxNQUFPLEVBQXhCLEdBQTRCRCxPQUpHLENBQXJCLEVBS2Y7QUFDRGpELE1BQUFBLEdBREM7QUFFRE8sTUFBQUEsSUFBSSxFQUFFLElBRkw7QUFHREMsTUFBQUEsUUFBUSxFQUFFLEtBQUtULHVCQUFMLENBQTZCQyxHQUE3QjtBQUhULEtBTGUsQ0FBbEI7O0FBV0EsUUFBSXdELEdBQUcsQ0FBQ2pELElBQVIsRUFBYztBQUdaLFVBQUlpRCxHQUFHLENBQUNqRCxJQUFKLENBQVNrRCxLQUFiLEVBQW9CO0FBQ2xCLGNBQU0sSUFBSTdCLEtBQUosQ0FBVTRCLEdBQUcsQ0FBQ2pELElBQUosQ0FBU2tELEtBQW5CLENBQU47QUFDRDtBQUNGOztBQU1ELFVBQU1DLFdBQVcsR0FBRywwQkFBWTFELEdBQVosRUFBa0IsR0FBRWlELE9BQVEsZUFBNUIsQ0FBcEI7O0FBQ0EsUUFBSTtBQUNGLGFBQU9VLE9BQU8sQ0FBQ0QsV0FBRCxDQUFkO0FBQ0QsS0FGRCxDQUVFLE1BQU07QUFDTixZQUFNLElBQUk5QixLQUFKLENBQVUsZ0VBQ0EsdURBREEsR0FFQThCLFdBRlYsQ0FBTjtBQUdEO0FBQ0Y7O0FBT2dCLFFBQVhFLFdBQVcsQ0FBRTVELEdBQUYsRUFBTzZELE9BQVAsRUFBZ0I7QUFHL0IsUUFBSVosT0FBSjs7QUFDQSxRQUFJO0FBQ0ZBLE1BQUFBLE9BQU8sR0FBR1UsT0FBTyxDQUFDakUsY0FBSzBELE9BQUwsQ0FBYVMsT0FBYixFQUFzQixjQUF0QixDQUFELENBQVAsQ0FBK0NDLElBQXpEO0FBQ0QsS0FGRCxDQUVFLE1BQU07QUFDTixZQUFNLElBQUlsQyxLQUFKLENBQVUseURBQ0MsYUFBWWlDLE9BQVEsRUFEL0IsQ0FBTjtBQUVEOztBQUlEQSxJQUFBQSxPQUFPLEdBQUduRSxjQUFLMEQsT0FBTCxDQUFhVyxPQUFPLENBQUMvRCxHQUFSLEVBQWIsRUFBNEI2RCxPQUE1QixDQUFWO0FBR0EsVUFBTXpELElBQUksR0FBRyxDQUNYLGdCQURXLEVBRVgsbUJBRlcsRUFHWHlELE9BSFcsQ0FBYjtBQUtBLFVBQU1MLEdBQUcsR0FBRyxNQUFNLEtBQUt0RCxJQUFMLENBQVUsTUFBVixFQUFrQkUsSUFBbEIsRUFBd0I7QUFBQ0osTUFBQUEsR0FBRDtBQUFNUSxNQUFBQSxRQUFRLEVBQUUsS0FBS1Asb0JBQUwsQ0FBMEJELEdBQTFCO0FBQWhCLEtBQXhCLENBQWxCOztBQUNBLFFBQUl3RCxHQUFHLENBQUNqRCxJQUFKLElBQVlpRCxHQUFHLENBQUNqRCxJQUFKLENBQVNrRCxLQUF6QixFQUFnQztBQUM5QixZQUFNLElBQUk3QixLQUFKLENBQVU0QixHQUFHLENBQUNqRCxJQUFKLENBQVNrRCxLQUFuQixDQUFOO0FBQ0Q7O0FBR0QsUUFBSTtBQUNGLGFBQU9FLE9BQU8sQ0FBQywwQkFBWTNELEdBQVosRUFBa0IsR0FBRWlELE9BQVEsZUFBNUIsQ0FBRCxDQUFkO0FBQ0QsS0FGRCxDQUVFLE1BQU07QUFDTixZQUFNLElBQUlyQixLQUFKLENBQVUsNERBQ0EsaUNBRFYsQ0FBTjtBQUVEO0FBQ0Y7O0FBTXFCLFFBQWhCb0MsZ0JBQWdCLENBQUVoRSxHQUFGLEVBQU8rQixHQUFQLEVBQVk7QUFDaEMsVUFBTSxLQUFLN0IsSUFBTCxDQUFVLFdBQVYsRUFBdUIsQ0FBQzZCLEdBQUQsQ0FBdkIsRUFBOEI7QUFDbEMvQixNQUFBQSxHQURrQztBQUVsQ1EsTUFBQUEsUUFBUSxFQUFFLEtBQUtULHVCQUFMLENBQTZCQyxHQUE3QjtBQUZ3QixLQUE5QixDQUFOO0FBSUQ7O0FBalBjOzs7QUFvUFYsTUFBTWlFLEdBQUcsR0FBRyxJQUFJbkUsR0FBSixFQUFaIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQHRzLWNoZWNrXG5cbmltcG9ydCBwYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0IHNlbXZlciBmcm9tICdzZW12ZXInO1xuaW1wb3J0IHsgZXhlYyB9IGZyb20gJ3RlZW5fcHJvY2Vzcyc7XG5pbXBvcnQgeyBmcyB9IGZyb20gJy4vZnMnO1xuaW1wb3J0ICogYXMgdXRpbCBmcm9tICcuL3V0aWwnO1xuaW1wb3J0ICogYXMgc3lzdGVtIGZyb20gJy4vc3lzdGVtJztcbmltcG9ydCByZXNvbHZlRnJvbSBmcm9tICdyZXNvbHZlLWZyb20nO1xuXG5cbi8qKlxuICogUmVsYXRpdmUgcGF0aCB0byBkaXJlY3RvcnkgY29udGFpbmluZyBhbnkgQXBwaXVtIGludGVybmFsIGZpbGVzXG4gKiBYWFg6IHRoaXMgaXMgZHVwbGljYXRlZCBpbiBgYXBwaXVtL2xpYi9jb25zdGFudHMuanNgLlxuICovXG5leHBvcnQgY29uc3QgQ0FDSEVfRElSX1JFTEFUSVZFX1BBVEggPSBwYXRoLmpvaW4oXG4gICdub2RlX21vZHVsZXMnLFxuICAnLmNhY2hlJyxcbiAgJ2FwcGl1bScsXG4pO1xuXG4vKipcbiAqIFJlbGF0aXZlIHBhdGggdG8gbG9ja2ZpbGUgdXNlZCB3aGVuIGluc3RhbGxpbmcgYW4gZXh0ZW5zaW9uIHZpYSBgYXBwaXVtYFxuICovXG5leHBvcnQgY29uc3QgSU5TVEFMTF9MT0NLRklMRV9SRUxBVElWRV9QQVRIID0gcGF0aC5qb2luKFxuICBDQUNIRV9ESVJfUkVMQVRJVkVfUEFUSCxcbiAgJy5pbnN0YWxsLmxvY2snLFxuKTtcblxuLyoqXG4gKiBSZWxhdGl2ZSBwYXRoIHRvIGxvY2tmaWxlIHVzZWQgd2hlbiBsaW5raW5nIGFuIGV4dGVuc2lvbiB2aWEgYGFwcGl1bWBcbiAqL1xuZXhwb3J0IGNvbnN0IExJTktfTE9DS0ZJTEVfUkVMQVRJVkVfUEFUSCA9IHBhdGguam9pbihcbiAgQ0FDSEVfRElSX1JFTEFUSVZFX1BBVEgsXG4gICcubGluay5sb2NrJyxcbik7XG5cbi8qKlxuICogWFhYOiBUaGlzIHNob3VsZCBwcm9iYWJseSBiZSBhIHNpbmdsZXRvbiwgYnV0IGl0IGlzbid0LiAgTWF5YmUgdGhpcyBtb2R1bGUgc2hvdWxkIGp1c3QgZXhwb3J0IGZ1bmN0aW9ucz9cbiAqL1xuZXhwb3J0IGNsYXNzIE5QTSB7XG4gIC8qKlxuICAgKiBSZXR1cm5zIHBhdGggdG8gXCJpbnN0YWxsXCIgbG9ja2ZpbGVcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGN3ZFxuICAgKi9cbiAgX2dldEluc3RhbGxMb2NrZmlsZVBhdGggKGN3ZCkge1xuICAgIHJldHVybiBwYXRoLmpvaW4oY3dkLCBJTlNUQUxMX0xPQ0tGSUxFX1JFTEFUSVZFX1BBVEgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgcGF0aCB0byBcImxpbmtcIiBsb2NrZmlsZVxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gY3dkXG4gICAqL1xuICBfZ2V0TGlua0xvY2tmaWxlUGF0aCAoY3dkKSB7XG4gICAgcmV0dXJuIHBhdGguam9pbihjd2QsIExJTktfTE9DS0ZJTEVfUkVMQVRJVkVfUEFUSCk7XG4gIH1cblxuICAvKipcbiAgICogRXhlY3V0ZSBgbnBtYCB3aXRoIGdpdmVuIGFyZ3MuXG4gICAqXG4gICAqIElmIHRoZSBwcm9jZXNzIGV4aXRzIHdpdGggYSBub256ZXJvIGNvZGUsIHRoZSBjb250ZW50cyBvZiBgU1RET1VUYCBhbmQgYFNUREVSUmAgd2lsbCBiZSBpbiB0aGVcbiAgICogYG1lc3NhZ2VgIG9mIHRoZSB7QGxpbmsgVGVlblByb2Nlc3NFeGVjRXJyb3J9IHJlamVjdGVkLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY21kXG4gICAqIEBwYXJhbSB7c3RyaW5nW119IGFyZ3NcbiAgICogQHBhcmFtIHtFeGVjT3B0c30gb3B0c1xuICAgKiBAcGFyYW0ge1RlZW5Qcm9jZXNzRXhlY09wdHN9IFtleGVjT3B0c11cbiAgICovXG4gIGFzeW5jIGV4ZWMgKGNtZCwgYXJncywgb3B0cywgZXhlY09wdHMgPSB7fSkge1xuICAgIGxldCB7IGN3ZCwganNvbiwgbG9ja0ZpbGUgfSA9IG9wdHM7XG5cbiAgICAvLyBtYWtlIHN1cmUgd2UgcGVyZm9ybSB0aGUgY3VycmVudCBvcGVyYXRpb24gaW4gY3dkXG4gICAgZXhlY09wdHMgPSB7Li4uZXhlY09wdHMsIGN3ZH07XG5cbiAgICBhcmdzLnVuc2hpZnQoY21kKTtcbiAgICBpZiAoanNvbikge1xuICAgICAgYXJncy5wdXNoKCctLWpzb24nKTtcbiAgICB9XG4gICAgY29uc3QgbnBtQ21kID0gc3lzdGVtLmlzV2luZG93cygpID8gJ25wbS5jbWQnIDogJ25wbSc7XG4gICAgbGV0IHJ1bm5lciA9IGFzeW5jICgpID0+IGF3YWl0IGV4ZWMobnBtQ21kLCBhcmdzLCBleGVjT3B0cyk7XG4gICAgaWYgKGxvY2tGaWxlKSB7XG4gICAgICBjb25zdCBhY3F1aXJlTG9jayA9IHV0aWwuZ2V0TG9ja0ZpbGVHdWFyZChsb2NrRmlsZSk7XG4gICAgICBjb25zdCBfcnVubmVyID0gcnVubmVyO1xuICAgICAgcnVubmVyID0gYXN5bmMgKCkgPT4gYXdhaXQgYWNxdWlyZUxvY2soX3J1bm5lcik7XG4gICAgfVxuXG4gICAgbGV0IHJldDtcbiAgICB0cnkge1xuICAgICAgY29uc3Qge3N0ZG91dCwgc3RkZXJyLCBjb2RlfSA9IGF3YWl0IHJ1bm5lcigpO1xuICAgICAgcmV0ID0gLyoqIEB0eXBlIHtUZWVuUHJvY2Vzc0V4ZWNSZXN1bHR9ICovKHtzdGRvdXQsIHN0ZGVyciwgY29kZX0pO1xuICAgICAgLy8gaWYgcG9zc2libGUsIHBhcnNlIE5QTSdzIGpzb24gb3V0cHV0LiBEdXJpbmcgTlBNIGluc3RhbGwgM3JkLXBhcnR5XG4gICAgICAvLyBwYWNrYWdlcyBjYW4gd3JpdGUgdG8gc3Rkb3V0LCBzbyBzb21ldGltZXMgdGhlIGpzb24gb3V0cHV0IGNhbid0IGJlXG4gICAgICAvLyBndWFyYW50ZWVkIHRvIGJlIHBhcnNlYWJsZVxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0Lmpzb24gPSBKU09OLnBhcnNlKHN0ZG91dCk7XG4gICAgICB9IGNhdGNoIChpZ24pIHt9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29uc3Qge3N0ZG91dCA9ICcnLCBzdGRlcnIgPSAnJywgY29kZSA9IG51bGx9ID0gLyoqIEB0eXBlIHtUZWVuUHJvY2Vzc0V4ZWNFcnJvcn0gKi8oZSk7XG4gICAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoYG5wbSBjb21tYW5kICcke2FyZ3Muam9pbignICcpfScgZmFpbGVkIHdpdGggY29kZSAke2NvZGV9LlxcblxcblNURE9VVDpcXG4ke3N0ZG91dC50cmltKCl9XFxuXFxuU1RERVJSOlxcbiR7c3RkZXJyLnRyaW0oKX1gKTtcbiAgICAgIHRocm93IGVycjtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY3dkXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwa2dcbiAgICovXG4gIGFzeW5jIGdldExhdGVzdFZlcnNpb24gKGN3ZCwgcGtnKSB7XG4gICAgcmV0dXJuIChhd2FpdCB0aGlzLmV4ZWMoJ3ZpZXcnLCBbcGtnLCAnZGlzdC10YWdzJ10sIHtcbiAgICAgIGpzb246IHRydWUsXG4gICAgICBjd2RcbiAgICB9KSkuanNvbj8ubGF0ZXN0O1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjd2RcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBrZ1xuICAgKiBAcGFyYW0ge3N0cmluZ30gY3VyVmVyc2lvblxuICAgKi9cbiAgYXN5bmMgZ2V0TGF0ZXN0U2FmZVVwZ3JhZGVWZXJzaW9uIChjd2QsIHBrZywgY3VyVmVyc2lvbikge1xuICAgIGNvbnN0IGFsbFZlcnNpb25zID0gKGF3YWl0IHRoaXMuZXhlYygndmlldycsIFtwa2csICd2ZXJzaW9ucyddLCB7XG4gICAgICBqc29uOiB0cnVlLFxuICAgICAgY3dkXG4gICAgfSkpLmpzb247XG4gICAgcmV0dXJuIHRoaXMuZ2V0TGF0ZXN0U2FmZVVwZ3JhZGVGcm9tVmVyc2lvbnMoY3VyVmVyc2lvbiwgYWxsVmVyc2lvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJ1bnMgYG5wbSBsc2AsIG9wdGlvbmFsbHkgZm9yIGEgcGFydGljdWxhciBwYWNrYWdlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY3dkXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbcGtnXVxuICAgKi9cbiAgYXN5bmMgbGlzdCAoY3dkLCBwa2cpIHtcbiAgICByZXR1cm4gKGF3YWl0IHRoaXMuZXhlYygnbGlzdCcsIHBrZyA/IFtwa2ddIDogW10sIHtjd2QsIGpzb246IHRydWV9KSkuanNvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHaXZlbiBhIGN1cnJlbnQgdmVyc2lvbiBhbmQgYSBsaXN0IG9mIGFsbCB2ZXJzaW9ucyBmb3IgYSBwYWNrYWdlLCByZXR1cm4gdGhlIHZlcnNpb24gd2hpY2ggaXNcbiAgICogdGhlIGhpZ2hlc3Qgc2FmZWx5LXVwZ3JhZGFibGUgdmVyc2lvbiAobWVhbmluZyBub3QgY3Jvc3NpbmcgYW55IG1ham9yIHJldmlzaW9uIGJvdW5kYXJpZXMsIGFuZFxuICAgKiBub3QgaW5jbHVkaW5nIGFueSBhbHBoYS9iZXRhL3JjIHZlcnNpb25zKVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY3VyVmVyc2lvbiAtIHRoZSBjdXJyZW50IHZlcnNpb24gb2YgYSBwYWNrYWdlXG4gICAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gYWxsVmVyc2lvbnMgLSBhIGxpc3Qgb2YgdmVyc2lvbiBzdHJpbmdzXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ3xudWxsfSAtIHRoZSBoaWdoZXN0IHNhZmVseS11cGdyYWRhYmxlIHZlcnNpb24sIG9yIG51bGwgaWYgdGhlcmUgaXNuJ3Qgb25lXG4gICAqL1xuICBnZXRMYXRlc3RTYWZlVXBncmFkZUZyb21WZXJzaW9ucyAoY3VyVmVyc2lvbiwgYWxsVmVyc2lvbnMpIHtcbiAgICBsZXQgc2FmZVVwZ3JhZGVWZXIgPSBudWxsO1xuICAgIGNvbnN0IGN1clNlbXZlciA9IHNlbXZlci5wYXJzZShjdXJWZXJzaW9uKTtcbiAgICBpZiAoY3VyU2VtdmVyID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkIG5vdCBwYXJzZSBjdXJyZW50IHZlcnNpb24gJyR7Y3VyVmVyc2lvbn0nYCk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgdGVzdFZlciBvZiBhbGxWZXJzaW9ucykge1xuICAgICAgY29uc3QgdGVzdFNlbXZlciA9IHNlbXZlci5wYXJzZSh0ZXN0VmVyKTtcbiAgICAgIGlmICh0ZXN0U2VtdmVyID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IHBhcnNlIHZlcnNpb24gdG8gdGVzdCBhZ2FpbnN0OiAnJHt0ZXN0VmVyfSdgKTtcbiAgICAgIH1cbiAgICAgIC8vIGlmIHRoZSB0ZXN0IHZlcnNpb24gaXMgYSBwcmVyZWxlYXNlLCBpZ25vcmUgaXRcbiAgICAgIGlmICh0ZXN0U2VtdmVyLnByZXJlbGVhc2UubGVuZ3RoID4gMCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIC8vIGlmIHRoZSBjdXJyZW50IHZlcnNpb24gaXMgbGF0ZXIgdGhhbiB0aGUgdGVzdCB2ZXJzaW9uLCBza2lwIHRoaXMgdGVzdCB2ZXJzaW9uXG4gICAgICBpZiAoY3VyU2VtdmVyLmNvbXBhcmUodGVzdFNlbXZlcikgPT09IDEpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICAvLyBpZiB0aGUgdGVzdCB2ZXJzaW9uIGlzIG5ld2VyLCBidXQgY3Jvc3NlcyBhIG1ham9yIHJldmlzaW9uIGJvdW5kYXJ5LCBhbHNvIHNraXAgaXRcbiAgICAgIGlmICh0ZXN0U2VtdmVyLm1ham9yID4gY3VyU2VtdmVyLm1ham9yKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgLy8gb3RoZXJ3aXNlIHRoaXMgdmVyc2lvbiBpcyBzYWZlIHRvIHVwZ3JhZGUgdG8uIEJ1dCB0aGVyZSBtaWdodCBiZSBtdWx0aXBsZSBvbmVzIG9mIHRoaXNcbiAgICAgIC8vIGtpbmQsIHNvIGtlZXAgaXRlcmF0aW5nIGFuZCBrZWVwaW5nIHRoZSBoaWdoZXN0XG4gICAgICBpZiAoc2FmZVVwZ3JhZGVWZXIgPT09IG51bGwgfHwgdGVzdFNlbXZlci5jb21wYXJlKHNhZmVVcGdyYWRlVmVyKSA9PT0gMSkge1xuICAgICAgICBzYWZlVXBncmFkZVZlciA9IHRlc3RTZW12ZXI7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChzYWZlVXBncmFkZVZlcikge1xuICAgICAgc2FmZVVwZ3JhZGVWZXIgPSBzYWZlVXBncmFkZVZlci5mb3JtYXQoKTtcbiAgICB9XG4gICAgcmV0dXJuIHNhZmVVcGdyYWRlVmVyO1xuICB9XG5cbiAgLyoqXG4gICAqIEluc3RhbGxzIGEgcGFja2FnZSB3LyBgbnBtYFxuICAgKiBAcGFyYW0ge3N0cmluZ30gY3dkXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwa2dOYW1lXG4gICAqIEBwYXJhbSB7SW5zdGFsbFBhY2thZ2VPcHRzfSBbb3B0c11cbiAgICogQHJldHVybnMge1Byb21pc2U8aW1wb3J0KCd0eXBlLWZlc3QnKS5QYWNrYWdlSnNvbj59XG4gICAqL1xuICBhc3luYyBpbnN0YWxsUGFja2FnZSAoY3dkLCBwa2dOYW1lLCB7cGtnVmVyfSA9IHt9KSB7XG4gICAgLy8gbm90IG9ubHkgdGhpcywgdGhpcyBkaXJlY3RvcnkgbmVlZHMgYSAncGFja2FnZS5qc29uJyBpbnNpZGUgb2YgaXQsIG90aGVyd2lzZSwgaWYgYW55XG4gICAgLy8gZGlyZWN0b3J5IGluIHRoZSBmaWxlc3lzdGVtIHRyZWUgQUJPVkUgY3dkIGhhcHBlbnMgdG8gaGF2ZSBhIHBhY2thZ2UuanNvbiBvciBhIG5vZGVfbW9kdWxlc1xuICAgIC8vIGRpciBpbiBpdCwgTlBNIHdpbGwgaW5zdGFsbCB0aGUgbW9kdWxlIHVwIHRoZXJlIGluc3RlYWQgKHNpbGx5IE5QTSlcbiAgICBjb25zdCBkdW1teVBrZ0pzb24gPSBwYXRoLnJlc29sdmUoY3dkLCAncGFja2FnZS5qc29uJyk7XG4gICAgaWYgKCFhd2FpdCBmcy5leGlzdHMoZHVtbXlQa2dKc29uKSkge1xuICAgICAgYXdhaXQgZnMud3JpdGVGaWxlKGR1bW15UGtnSnNvbiwgJ3t9Jyk7XG4gICAgfVxuXG4gICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5leGVjKCdpbnN0YWxsJywgW1xuICAgICAgJy0tbm8tc2F2ZScsXG4gICAgICAnLS1nbG9iYWwtc3R5bGUnLFxuICAgICAgJy0tbm8tcGFja2FnZS1sb2NrJyxcbiAgICAgIHBrZ1ZlciA/IGAke3BrZ05hbWV9QCR7cGtnVmVyfWAgOiBwa2dOYW1lXG4gICAgXSwge1xuICAgICAgY3dkLFxuICAgICAganNvbjogdHJ1ZSxcbiAgICAgIGxvY2tGaWxlOiB0aGlzLl9nZXRJbnN0YWxsTG9ja2ZpbGVQYXRoKGN3ZClcbiAgICB9KTtcblxuICAgIGlmIChyZXMuanNvbikge1xuICAgICAgLy8gd2UgcGFyc2VkIGEgdmFsaWQganNvbiByZXNwb25zZSwgc28gaWYgd2UgZ290IGFuIGVycm9yIGhlcmUsIHJldHVybiB0aGF0XG4gICAgICAvLyBtZXNzYWdlIHN0cmFpZ2h0YXdheVxuICAgICAgaWYgKHJlcy5qc29uLmVycm9yKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihyZXMuanNvbi5lcnJvcik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gTm93IHJlYWQgcGFja2FnZSBkYXRhIGZyb20gdGhlIGluc3RhbGxlZCBwYWNrYWdlIHRvIHJldHVybiwgYW5kIG1ha2Ugc3VyZVxuICAgIC8vIGV2ZXJ5dGhpbmcgZ290IGluc3RhbGxlZCBvay4gUmVtZW1iZXIsIHBrZ05hbWUgbWlnaHQgZW5kIHVwIHdpdGggYSAvIGluIGl0IGR1ZSB0byBhbiBucG1cbiAgICAvLyBvcmcsIHNvIGlmIHNvLCB0aGF0IHdpbGwgZ2V0IGNvcnJlY3RseSBleHBsb2RlZCBpbnRvIG11bHRpcGxlIGRpcmVjdG9yaWVzLCBieSBwYXRoLnJlc29sdmUgaGVyZVxuICAgIC8vIChldmVuIG9uIFdpbmRvd3MhKVxuICAgIGNvbnN0IHBrZ0pzb25QYXRoID0gcmVzb2x2ZUZyb20oY3dkLCBgJHtwa2dOYW1lfS9wYWNrYWdlLmpzb25gKTtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHJlcXVpcmUocGtnSnNvblBhdGgpO1xuICAgIH0gY2F0Y2gge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgcGFja2FnZSB3YXMgbm90IGRvd25sb2FkZWQgY29ycmVjdGx5OyBpdHMgcGFja2FnZS5qc29uICcgK1xuICAgICAgICAgICAgICAgICAgICAgICdkaWQgbm90IGV4aXN0IG9yIHdhcyB1bnJlYWRhYmxlLiBXZSBsb29rZWQgZm9yIGl0IGF0ICcgK1xuICAgICAgICAgICAgICAgICAgICAgIHBrZ0pzb25QYXRoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHRvZG86IEkgdGhpbmsgdGhpcyBjYW4gYmUgYW4gYGluc3RhbGxgIGluc3RlYWQgb2YgYSBgbGlua2AuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjd2RcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBrZ1BhdGhcbiAgICovXG4gIGFzeW5jIGxpbmtQYWNrYWdlIChjd2QsIHBrZ1BhdGgpIHtcbiAgICAvLyBmcm9tIHRoZSBwYXRoIGFsb25lIHdlIGRvbid0IGtub3cgdGhlIG5wbSBwYWNrYWdlIG5hbWUsIHNvIHdlIG5lZWQgdG9cbiAgICAvLyBsb29rIGluIHBhY2thZ2UuanNvblxuICAgIGxldCBwa2dOYW1lO1xuICAgIHRyeSB7XG4gICAgICBwa2dOYW1lID0gcmVxdWlyZShwYXRoLnJlc29sdmUocGtnUGF0aCwgJ3BhY2thZ2UuanNvbicpKS5uYW1lO1xuICAgIH0gY2F0Y2gge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgZmluZCBwYWNrYWdlLmpzb24gaW5zaWRlIHRoZSBwYWNrYWdlIHBhdGggJyArXG4gICAgICAgICAgICAgICAgICAgICAgYHByb3ZpZGVkOiAke3BrZ1BhdGh9YCk7XG4gICAgfVxuXG4gICAgLy8gdGhpcyBpcyBhZGRlZCB0byBoYW5kbGUgY29tbWFuZHMgd2l0aCByZWxhdGl2ZSBwYXRoc1xuICAgIC8vIGllOiBcIm5vZGUgLiBkcml2ZXIgaW5zdGFsbCAtLXNvdXJjZT1sb2NhbCAuLi9mYWtlLWRyaXZlclwiXG4gICAgcGtnUGF0aCA9IHBhdGgucmVzb2x2ZShwcm9jZXNzLmN3ZCgpLCBwa2dQYXRoKTtcblxuICAgIC8vIGNhbGwgbGluayB3aXRoIC0tbm8tcGFja2FnZS1sb2NrIHRvIGVuc3VyZSBubyBjb3JydXB0aW9uIHdoaWxlIGluc3RhbGxpbmcgbG9jYWwgcGFja2FnZXNcbiAgICBjb25zdCBhcmdzID0gW1xuICAgICAgJy0tZ2xvYmFsLXN0eWxlJyxcbiAgICAgICctLW5vLXBhY2thZ2UtbG9jaycsXG4gICAgICBwa2dQYXRoXG4gICAgXTtcbiAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLmV4ZWMoJ2xpbmsnLCBhcmdzLCB7Y3dkLCBsb2NrRmlsZTogdGhpcy5fZ2V0TGlua0xvY2tmaWxlUGF0aChjd2QpfSk7XG4gICAgaWYgKHJlcy5qc29uICYmIHJlcy5qc29uLmVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IocmVzLmpzb24uZXJyb3IpO1xuICAgIH1cblxuICAgIC8vIG5vdyBlbnN1cmUgaXQgd2FzIGxpbmtlZCB0byB0aGUgY29ycmVjdCBwbGFjZVxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gcmVxdWlyZShyZXNvbHZlRnJvbShjd2QsIGAke3BrZ05hbWV9L3BhY2thZ2UuanNvbmApKTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHBhY2thZ2Ugd2FzIG5vdCBsaW5rZWQgY29ycmVjdGx5OyBpdHMgcGFja2FnZS5qc29uICcgK1xuICAgICAgICAgICAgICAgICAgICAgICdkaWQgbm90IGV4aXN0IG9yIHdhcyB1bnJlYWRhYmxlJyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjd2RcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBrZ1xuICAgKi9cbiAgYXN5bmMgdW5pbnN0YWxsUGFja2FnZSAoY3dkLCBwa2cpIHtcbiAgICBhd2FpdCB0aGlzLmV4ZWMoJ3VuaW5zdGFsbCcsIFtwa2ddLCB7XG4gICAgICBjd2QsXG4gICAgICBsb2NrRmlsZTogdGhpcy5fZ2V0SW5zdGFsbExvY2tmaWxlUGF0aChjd2QpXG4gICAgfSk7XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IG5wbSA9IG5ldyBOUE0oKTtcblxuLyoqXG4gKiBPcHRpb25zIGZvciB7QGxpbmsgTlBNLmluc3RhbGxQYWNrYWdlfVxuICogQHR5cGVkZWYgSW5zdGFsbFBhY2thZ2VPcHRzXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW3BrZ1Zlcl0gLSB0aGUgdmVyc2lvbiBvZiB0aGUgcGFja2FnZSB0byBpbnN0YWxsXG4gKi9cblxuLyoqXG4gKiBPcHRpb25zIGZvciB7QGxpbmsgTlBNLmV4ZWN9XG4gKiBAdHlwZWRlZiBFeGVjT3B0c1xuICogQHByb3BlcnR5IHtzdHJpbmd9IGN3ZCAtIEN1cnJlbnQgd29ya2luZyBkaXJlY3RvcnlcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2pzb25dIC0gSWYgYHRydWVgLCBzdXBwbHkgYC0tanNvbmAgZmxhZyB0byBucG0gYW5kIHJlc29sdmUgdy8gcGFyc2VkIEpTT05cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbbG9ja0ZpbGVdIC0gUGF0aCB0byBsb2NrZmlsZSB0byB1c2VcbiAqL1xuXG4vLyBUSEVTRSBUWVBFUyBTSE9VTEQgQkUgSU4gVEVFTiBQUk9DRVNTLCBOT1QgSEVSRVxuXG4vKipcbiAqIFJlc3VsdCBmcm9tIGEgbm9uLXplcm8tZXhpdCBleGVjdXRpb24gb2YgYGFwcGl1bWBcbiAqIEB0eXBlZGVmIFRlZW5Qcm9jZXNzRXhlY1Jlc3VsdFxuICogQHByb3BlcnR5IHtzdHJpbmd9IHN0ZG91dCAtIFN0ZG91dFxuICogQHByb3BlcnR5IHtzdHJpbmd9IHN0ZGVyciAtIFN0ZGVyclxuICogQHByb3BlcnR5IHtudW1iZXI/fSBjb2RlIC0gRXhpdCBjb2RlXG4gKiBAcHJvcGVydHkge2FueX0ganNvbiAtIEpTT04gcGFyc2VkIGZyb20gc3Rkb3V0XG4gKi9cblxuLyoqXG4gKiBFeHRyYSBwcm9wcyBgdGVlbl9wcm9jZXNzLmV4ZWNgIGFkZHMgdG8gaXRzIGVycm9yIG9iamVjdHNcbiAqIEB0eXBlZGVmIFRlZW5Qcm9jZXNzRXhlY0Vycm9yUHJvcHNcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBzdGRvdXQgLSBTVERPVVRcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBzdGRlcnIgLSBTVERFUlJcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyP30gY29kZSAtIEV4aXQgY29kZVxuICovXG5cbi8qKlxuICogT3B0aW9ucyB1bmlxdWUgdG8gYHRlZW5fcHJvY2Vzcy5leGVjYC4gSSBwcm9iYWJseSBtaXNzZWQgc29tZVxuICogQHR5cGVkZWYgVGVlblByb2Nlc3NFeGVjRXh0cmFPcHRzXG4gKiBAcHJvcGVydHkge251bWJlcn0gW21heFN0ZG91dEJ1ZmZlclNpemVdXG4gKiBAcHJvcGVydHkge251bWJlcn0gW21heFN0ZGVyckJ1ZmZlclNpemVdXG4gKi9cblxuLyoqXG4gKiBBbGwgb3B0aW9ucyBmb3IgYHRlZW5fcHJvY2Vzcy5leGVjYFxuICogQHR5cGVkZWYge2ltcG9ydCgnY2hpbGRfcHJvY2VzcycpLlNwYXduT3B0aW9ucyAmIFRlZW5Qcm9jZXNzRXhlY0V4dHJhT3B0c30gVGVlblByb2Nlc3NFeGVjT3B0c1xuICovXG5cbi8qKlxuICogRXJyb3IgdGhyb3duIGJ5IGB0ZWVuX3Byb2Nlc3MuZXhlY2BcbiAqIEB0eXBlZGVmIHtFcnJvciAmIFRlZW5Qcm9jZXNzRXhlY0Vycm9yUHJvcHN9IFRlZW5Qcm9jZXNzRXhlY0Vycm9yXG4gKi9cbiJdfQ==